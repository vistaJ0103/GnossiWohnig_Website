{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function (str) {\n  var result = \"\";\n  for (var i = 0; i < str.length; i++) {\n    result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n  }\n  return result;\n};\nexports.arrayBuffer2Blob = function (buffer) {\n  exports.checkSupport(\"blob\");\n  try {\n    // Blob constructor\n    return new Blob([buffer], {\n      type: \"application/zip\"\n    });\n  } catch (e) {\n    try {\n      // deprecated, browser only, old way\n      var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n      var builder = new Builder();\n      builder.append(buffer);\n      return builder.getBlob('application/zip');\n    } catch (e) {\n      // well, fuck ?!\n      throw new Error(\"Bug : can't construct the Blob.\");\n    }\n  }\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n  return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n  for (var i = 0; i < str.length; ++i) {\n    array[i] = str.charCodeAt(i) & 0xFF;\n  }\n  return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n  // Performances notes :\n  // --------------------\n  // String.fromCharCode.apply(null, array) is the fastest, see\n  // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n  // but the stack is limited (and we can get huge arrays !).\n  //\n  // result += String.fromCharCode(array[i]); generate too many strings !\n  //\n  // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n  var chunk = 65536;\n  var result = [],\n    len = array.length,\n    type = exports.getTypeOf(array),\n    k = 0,\n    canUseApply = true;\n  try {\n    switch (type) {\n      case \"uint8array\":\n        String.fromCharCode.apply(null, new Uint8Array(0));\n        break;\n      case \"nodebuffer\":\n        String.fromCharCode.apply(null, nodeBuffer(0));\n        break;\n    }\n  } catch (e) {\n    canUseApply = false;\n  }\n\n  // no apply : slow and painful algorithm\n  // default browser on android 4.*\n  if (!canUseApply) {\n    var resultStr = \"\";\n    for (var i = 0; i < array.length; i++) {\n      resultStr += String.fromCharCode(array[i]);\n    }\n    return resultStr;\n  }\n  while (k < len && chunk > 1) {\n    try {\n      if (type === \"array\" || type === \"nodebuffer\") {\n        result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n      } else {\n        result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n      }\n      k += chunk;\n    } catch (e) {\n      chunk = Math.floor(chunk / 2);\n    }\n  }\n  return result.join(\"\");\n}\nexports.applyFromCharCode = arrayLikeToString;\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n  for (var i = 0; i < arrayFrom.length; i++) {\n    arrayTo[i] = arrayFrom[i];\n  }\n  return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n  \"string\": identity,\n  \"array\": function (input) {\n    return stringToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"string\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return stringToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": function (input) {\n    return stringToArrayLike(input, nodeBuffer(input.length));\n  }\n};\n\n// array to ?\ntransform[\"array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": identity,\n  \"arraybuffer\": function (input) {\n    return new Uint8Array(input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n  \"string\": function (input) {\n    return arrayLikeToString(new Uint8Array(input));\n  },\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n  },\n  \"arraybuffer\": identity,\n  \"uint8array\": function (input) {\n    return new Uint8Array(input);\n  },\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(new Uint8Array(input));\n  }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return input.buffer;\n  },\n  \"uint8array\": identity,\n  \"nodebuffer\": function (input) {\n    return nodeBuffer(input);\n  }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n  \"string\": arrayLikeToString,\n  \"array\": function (input) {\n    return arrayLikeToArrayLike(input, new Array(input.length));\n  },\n  \"arraybuffer\": function (input) {\n    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n  },\n  \"uint8array\": function (input) {\n    return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n  },\n  \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function (outputType, input) {\n  if (!input) {\n    // undefined, null, etc\n    // an empty string won't harm.\n    input = \"\";\n  }\n  if (!outputType) {\n    return input;\n  }\n  exports.checkSupport(outputType);\n  var inputType = exports.getTypeOf(input);\n  var result = transform[inputType][outputType](input);\n  return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function (input) {\n  if (typeof input === \"string\") {\n    return \"string\";\n  }\n  if (Object.prototype.toString.call(input) === \"[object Array]\") {\n    return \"array\";\n  }\n  if (support.nodebuffer && nodeBuffer.test(input)) {\n    return \"nodebuffer\";\n  }\n  if (support.uint8array && input instanceof Uint8Array) {\n    return \"uint8array\";\n  }\n  if (support.arraybuffer && input instanceof ArrayBuffer) {\n    return \"arraybuffer\";\n  }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function (type) {\n  var supported = support[type.toLowerCase()];\n  if (!supported) {\n    throw new Error(type + \" is not supported by this browser\");\n  }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function (str) {\n  var res = '',\n    code,\n    i;\n  for (i = 0; i < (str || \"\").length; i++) {\n    code = str.charCodeAt(i);\n    res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n  }\n  return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function (compressionMethod) {\n  for (var method in compressions) {\n    if (!compressions.hasOwnProperty(method)) {\n      continue;\n    }\n    if (compressions[method].magic === compressionMethod) {\n      return compressions[method];\n    }\n  }\n  return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n  return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};","map":{"version":3,"names":["support","require","compressions","nodeBuffer","exports","string2binary","str","result","i","length","String","fromCharCode","charCodeAt","arrayBuffer2Blob","buffer","checkSupport","Blob","type","e","Builder","window","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","builder","append","getBlob","Error","identity","input","stringToArrayLike","array","arrayLikeToString","chunk","len","getTypeOf","k","canUseApply","apply","Uint8Array","resultStr","push","slice","Math","min","subarray","floor","join","applyFromCharCode","arrayLikeToArrayLike","arrayFrom","arrayTo","transform","Array","byteLength","transformTo","outputType","inputType","Object","prototype","toString","call","nodebuffer","test","uint8array","arraybuffer","ArrayBuffer","supported","toLowerCase","MAX_VALUE_16BITS","MAX_VALUE_32BITS","pretty","res","code","toUpperCase","findCompression","compressionMethod","method","hasOwnProperty","magic","isRegExp","object"],"sources":["/Users/corneliascherrer/TecFox Projects/WebsiteVorlage/website-vorlage/node_modules/jszip/lib/utils.js"],"sourcesContent":["'use strict';\nvar support = require('./support');\nvar compressions = require('./compressions');\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer) {\n    exports.checkSupport(\"blob\");\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: \"application/zip\"\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob('application/zip');\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIC,YAAY,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC5C,IAAIE,UAAU,GAAGF,OAAO,CAAC,cAAc,CAAC;AACxC;AACA;AACA;AACA;AACA;AACAG,OAAO,CAACC,aAAa,GAAG,UAASC,GAAG,EAAE;EAClC,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACjCD,MAAM,IAAIG,MAAM,CAACC,YAAY,CAACL,GAAG,CAACM,UAAU,CAACJ,CAAC,CAAC,GAAG,IAAI,CAAC;EAC3D;EACA,OAAOD,MAAM;AACjB,CAAC;AACDH,OAAO,CAACS,gBAAgB,GAAG,UAASC,MAAM,EAAE;EACxCV,OAAO,CAACW,YAAY,CAAC,MAAM,CAAC;EAE5B,IAAI;IACA;IACA,OAAO,IAAIC,IAAI,CAAC,CAACF,MAAM,CAAC,EAAE;MACtBG,IAAI,EAAE;IACV,CAAC,CAAC;EACN,CAAC,CACD,OAAOC,CAAC,EAAE;IAEN,IAAI;MACA;MACA,IAAIC,OAAO,GAAGC,MAAM,CAACC,WAAW,IAAID,MAAM,CAACE,iBAAiB,IAAIF,MAAM,CAACG,cAAc,IAAIH,MAAM,CAACI,aAAa;MAC7G,IAAIC,OAAO,GAAG,IAAIN,OAAO,EAAE;MAC3BM,OAAO,CAACC,MAAM,CAACZ,MAAM,CAAC;MACtB,OAAOW,OAAO,CAACE,OAAO,CAAC,iBAAiB,CAAC;IAC7C,CAAC,CACD,OAAOT,CAAC,EAAE;MAEN;MACA,MAAM,IAAIU,KAAK,CAAC,iCAAiC,CAAC;IACtD;EACJ;AAGJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQ,CAACC,KAAK,EAAE;EACrB,OAAOA,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiB,CAACzB,GAAG,EAAE0B,KAAK,EAAE;EACnC,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACG,MAAM,EAAE,EAAED,CAAC,EAAE;IACjCwB,KAAK,CAACxB,CAAC,CAAC,GAAGF,GAAG,CAACM,UAAU,CAACJ,CAAC,CAAC,GAAG,IAAI;EACvC;EACA,OAAOwB,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,iBAAiB,CAACD,KAAK,EAAE;EAC9B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIE,KAAK,GAAG,KAAK;EACjB,IAAI3B,MAAM,GAAG,EAAE;IACX4B,GAAG,GAAGH,KAAK,CAACvB,MAAM;IAClBQ,IAAI,GAAGb,OAAO,CAACgC,SAAS,CAACJ,KAAK,CAAC;IAC/BK,CAAC,GAAG,CAAC;IACLC,WAAW,GAAG,IAAI;EACpB,IAAI;IACD,QAAOrB,IAAI;MACR,KAAK,YAAY;QACdP,MAAM,CAACC,YAAY,CAAC4B,KAAK,CAAC,IAAI,EAAE,IAAIC,UAAU,CAAC,CAAC,CAAC,CAAC;QAClD;MACH,KAAK,YAAY;QACd9B,MAAM,CAACC,YAAY,CAAC4B,KAAK,CAAC,IAAI,EAAEpC,UAAU,CAAC,CAAC,CAAC,CAAC;QAC9C;IAAM;EAEf,CAAC,CAAC,OAAMe,CAAC,EAAE;IACRoB,WAAW,GAAG,KAAK;EACtB;;EAEA;EACA;EACA,IAAI,CAACA,WAAW,EAAE;IACf,IAAIG,SAAS,GAAG,EAAE;IAClB,KAAI,IAAIjC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwB,KAAK,CAACvB,MAAM,EAACD,CAAC,EAAE,EAAE;MAClCiC,SAAS,IAAI/B,MAAM,CAACC,YAAY,CAACqB,KAAK,CAACxB,CAAC,CAAC,CAAC;IAC7C;IACL,OAAOiC,SAAS;EAChB;EACA,OAAOJ,CAAC,GAAGF,GAAG,IAAID,KAAK,GAAG,CAAC,EAAE;IACzB,IAAI;MACA,IAAIjB,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,YAAY,EAAE;QAC3CV,MAAM,CAACmC,IAAI,CAAChC,MAAM,CAACC,YAAY,CAAC4B,KAAK,CAAC,IAAI,EAAEP,KAAK,CAACW,KAAK,CAACN,CAAC,EAAEO,IAAI,CAACC,GAAG,CAACR,CAAC,GAAGH,KAAK,EAAEC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC1F,CAAC,MACI;QACD5B,MAAM,CAACmC,IAAI,CAAChC,MAAM,CAACC,YAAY,CAAC4B,KAAK,CAAC,IAAI,EAAEP,KAAK,CAACc,QAAQ,CAACT,CAAC,EAAEO,IAAI,CAACC,GAAG,CAACR,CAAC,GAAGH,KAAK,EAAEC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC7F;MACAE,CAAC,IAAIH,KAAK;IACd,CAAC,CACD,OAAOhB,CAAC,EAAE;MACNgB,KAAK,GAAGU,IAAI,CAACG,KAAK,CAACb,KAAK,GAAG,CAAC,CAAC;IACjC;EACJ;EACA,OAAO3B,MAAM,CAACyC,IAAI,CAAC,EAAE,CAAC;AAC1B;AAEA5C,OAAO,CAAC6C,iBAAiB,GAAGhB,iBAAiB;;AAG7C;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,oBAAoB,CAACC,SAAS,EAAEC,OAAO,EAAE;EAC9C,KAAK,IAAI5C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2C,SAAS,CAAC1C,MAAM,EAAED,CAAC,EAAE,EAAE;IACvC4C,OAAO,CAAC5C,CAAC,CAAC,GAAG2C,SAAS,CAAC3C,CAAC,CAAC;EAC7B;EACA,OAAO4C,OAAO;AAClB;;AAEA;AACA,IAAIC,SAAS,GAAG,CAAC,CAAC;;AAElB;AACAA,SAAS,CAAC,QAAQ,CAAC,GAAG;EAClB,QAAQ,EAAExB,QAAQ;EAClB,OAAO,EAAE,UAASC,KAAK,EAAE;IACrB,OAAOC,iBAAiB,CAACD,KAAK,EAAE,IAAIwB,KAAK,CAACxB,KAAK,CAACrB,MAAM,CAAC,CAAC;EAC5D,CAAC;EACD,aAAa,EAAE,UAASqB,KAAK,EAAE;IAC3B,OAAOuB,SAAS,CAAC,QAAQ,CAAC,CAAC,YAAY,CAAC,CAACvB,KAAK,CAAC,CAAChB,MAAM;EAC1D,CAAC;EACD,YAAY,EAAE,UAASgB,KAAK,EAAE;IAC1B,OAAOC,iBAAiB,CAACD,KAAK,EAAE,IAAIU,UAAU,CAACV,KAAK,CAACrB,MAAM,CAAC,CAAC;EACjE,CAAC;EACD,YAAY,EAAE,UAASqB,KAAK,EAAE;IAC1B,OAAOC,iBAAiB,CAACD,KAAK,EAAE3B,UAAU,CAAC2B,KAAK,CAACrB,MAAM,CAAC,CAAC;EAC7D;AACJ,CAAC;;AAED;AACA4C,SAAS,CAAC,OAAO,CAAC,GAAG;EACjB,QAAQ,EAAEpB,iBAAiB;EAC3B,OAAO,EAAEJ,QAAQ;EACjB,aAAa,EAAE,UAASC,KAAK,EAAE;IAC3B,OAAQ,IAAIU,UAAU,CAACV,KAAK,CAAC,CAAEhB,MAAM;EACzC,CAAC;EACD,YAAY,EAAE,UAASgB,KAAK,EAAE;IAC1B,OAAO,IAAIU,UAAU,CAACV,KAAK,CAAC;EAChC,CAAC;EACD,YAAY,EAAE,UAASA,KAAK,EAAE;IAC1B,OAAO3B,UAAU,CAAC2B,KAAK,CAAC;EAC5B;AACJ,CAAC;;AAED;AACAuB,SAAS,CAAC,aAAa,CAAC,GAAG;EACvB,QAAQ,EAAE,UAASvB,KAAK,EAAE;IACtB,OAAOG,iBAAiB,CAAC,IAAIO,UAAU,CAACV,KAAK,CAAC,CAAC;EACnD,CAAC;EACD,OAAO,EAAE,UAASA,KAAK,EAAE;IACrB,OAAOoB,oBAAoB,CAAC,IAAIV,UAAU,CAACV,KAAK,CAAC,EAAE,IAAIwB,KAAK,CAACxB,KAAK,CAACyB,UAAU,CAAC,CAAC;EACnF,CAAC;EACD,aAAa,EAAE1B,QAAQ;EACvB,YAAY,EAAE,UAASC,KAAK,EAAE;IAC1B,OAAO,IAAIU,UAAU,CAACV,KAAK,CAAC;EAChC,CAAC;EACD,YAAY,EAAE,UAASA,KAAK,EAAE;IAC1B,OAAO3B,UAAU,CAAC,IAAIqC,UAAU,CAACV,KAAK,CAAC,CAAC;EAC5C;AACJ,CAAC;;AAED;AACAuB,SAAS,CAAC,YAAY,CAAC,GAAG;EACtB,QAAQ,EAAEpB,iBAAiB;EAC3B,OAAO,EAAE,UAASH,KAAK,EAAE;IACrB,OAAOoB,oBAAoB,CAACpB,KAAK,EAAE,IAAIwB,KAAK,CAACxB,KAAK,CAACrB,MAAM,CAAC,CAAC;EAC/D,CAAC;EACD,aAAa,EAAE,UAASqB,KAAK,EAAE;IAC3B,OAAOA,KAAK,CAAChB,MAAM;EACvB,CAAC;EACD,YAAY,EAAEe,QAAQ;EACtB,YAAY,EAAE,UAASC,KAAK,EAAE;IAC1B,OAAO3B,UAAU,CAAC2B,KAAK,CAAC;EAC5B;AACJ,CAAC;;AAED;AACAuB,SAAS,CAAC,YAAY,CAAC,GAAG;EACtB,QAAQ,EAAEpB,iBAAiB;EAC3B,OAAO,EAAE,UAASH,KAAK,EAAE;IACrB,OAAOoB,oBAAoB,CAACpB,KAAK,EAAE,IAAIwB,KAAK,CAACxB,KAAK,CAACrB,MAAM,CAAC,CAAC;EAC/D,CAAC;EACD,aAAa,EAAE,UAASqB,KAAK,EAAE;IAC3B,OAAOuB,SAAS,CAAC,YAAY,CAAC,CAAC,YAAY,CAAC,CAACvB,KAAK,CAAC,CAAChB,MAAM;EAC9D,CAAC;EACD,YAAY,EAAE,UAASgB,KAAK,EAAE;IAC1B,OAAOoB,oBAAoB,CAACpB,KAAK,EAAE,IAAIU,UAAU,CAACV,KAAK,CAACrB,MAAM,CAAC,CAAC;EACpE,CAAC;EACD,YAAY,EAAEoB;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAzB,OAAO,CAACoD,WAAW,GAAG,UAASC,UAAU,EAAE3B,KAAK,EAAE;EAC9C,IAAI,CAACA,KAAK,EAAE;IACR;IACA;IACAA,KAAK,GAAG,EAAE;EACd;EACA,IAAI,CAAC2B,UAAU,EAAE;IACb,OAAO3B,KAAK;EAChB;EACA1B,OAAO,CAACW,YAAY,CAAC0C,UAAU,CAAC;EAChC,IAAIC,SAAS,GAAGtD,OAAO,CAACgC,SAAS,CAACN,KAAK,CAAC;EACxC,IAAIvB,MAAM,GAAG8C,SAAS,CAACK,SAAS,CAAC,CAACD,UAAU,CAAC,CAAC3B,KAAK,CAAC;EACpD,OAAOvB,MAAM;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAH,OAAO,CAACgC,SAAS,GAAG,UAASN,KAAK,EAAE;EAChC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAO,QAAQ;EACnB;EACA,IAAI6B,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAAChC,KAAK,CAAC,KAAK,gBAAgB,EAAE;IAC5D,OAAO,OAAO;EAClB;EACA,IAAI9B,OAAO,CAAC+D,UAAU,IAAI5D,UAAU,CAAC6D,IAAI,CAAClC,KAAK,CAAC,EAAE;IAC9C,OAAO,YAAY;EACvB;EACA,IAAI9B,OAAO,CAACiE,UAAU,IAAInC,KAAK,YAAYU,UAAU,EAAE;IACnD,OAAO,YAAY;EACvB;EACA,IAAIxC,OAAO,CAACkE,WAAW,IAAIpC,KAAK,YAAYqC,WAAW,EAAE;IACrD,OAAO,aAAa;EACxB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA/D,OAAO,CAACW,YAAY,GAAG,UAASE,IAAI,EAAE;EAClC,IAAImD,SAAS,GAAGpE,OAAO,CAACiB,IAAI,CAACoD,WAAW,EAAE,CAAC;EAC3C,IAAI,CAACD,SAAS,EAAE;IACZ,MAAM,IAAIxC,KAAK,CAACX,IAAI,GAAG,mCAAmC,CAAC;EAC/D;AACJ,CAAC;AACDb,OAAO,CAACkE,gBAAgB,GAAG,KAAK;AAChClE,OAAO,CAACmE,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;;AAE/B;AACA;AACA;AACA;AACA;AACAnE,OAAO,CAACoE,MAAM,GAAG,UAASlE,GAAG,EAAE;EAC3B,IAAImE,GAAG,GAAG,EAAE;IACRC,IAAI;IAAElE,CAAC;EACX,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAACF,GAAG,IAAI,EAAE,EAAEG,MAAM,EAAED,CAAC,EAAE,EAAE;IACrCkE,IAAI,GAAGpE,GAAG,CAACM,UAAU,CAACJ,CAAC,CAAC;IACxBiE,GAAG,IAAI,KAAK,IAAIC,IAAI,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,CAAC,GAAGA,IAAI,CAACb,QAAQ,CAAC,EAAE,CAAC,CAACc,WAAW,EAAE;EAC3E;EACA,OAAOF,GAAG;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACArE,OAAO,CAACwE,eAAe,GAAG,UAASC,iBAAiB,EAAE;EAClD,KAAK,IAAIC,MAAM,IAAI5E,YAAY,EAAE;IAC7B,IAAI,CAACA,YAAY,CAAC6E,cAAc,CAACD,MAAM,CAAC,EAAE;MACtC;IACJ;IACA,IAAI5E,YAAY,CAAC4E,MAAM,CAAC,CAACE,KAAK,KAAKH,iBAAiB,EAAE;MAClD,OAAO3E,YAAY,CAAC4E,MAAM,CAAC;IAC/B;EACJ;EACA,OAAO,IAAI;AACf,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA1E,OAAO,CAAC6E,QAAQ,GAAG,UAAUC,MAAM,EAAE;EACjC,OAAOvB,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACoB,MAAM,CAAC,KAAK,iBAAiB;AACvE,CAAC"},"metadata":{},"sourceType":"script"}