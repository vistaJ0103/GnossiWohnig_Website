{"ast":null,"code":"'use strict';\n\nvar StringReader = require('./stringReader');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar jszipProto = require('./object');\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n  this.options = options;\n  this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n  /**\n   * say if the file is encrypted.\n   * @return {boolean} true if the file is encrypted, false otherwise.\n   */\n  isEncrypted: function () {\n    // bit 1 is set\n    return (this.bitFlag & 0x0001) === 0x0001;\n  },\n  /**\n   * say if the file has utf-8 filename/comment.\n   * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n   */\n  useUTF8: function () {\n    // bit 11 is set\n    return (this.bitFlag & 0x0800) === 0x0800;\n  },\n  /**\n   * Prepare the function used to generate the compressed content from this ZipFile.\n   * @param {DataReader} reader the reader to use.\n   * @param {number} from the offset from where we should read the data.\n   * @param {number} length the length of the data to read.\n   * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).\n   */\n  prepareCompressedContent: function (reader, from, length) {\n    return function () {\n      var previousIndex = reader.index;\n      reader.setIndex(from);\n      var compressedFileData = reader.readData(length);\n      reader.setIndex(previousIndex);\n      return compressedFileData;\n    };\n  },\n  /**\n   * Prepare the function used to generate the uncompressed content from this ZipFile.\n   * @param {DataReader} reader the reader to use.\n   * @param {number} from the offset from where we should read the data.\n   * @param {number} length the length of the data to read.\n   * @param {JSZip.compression} compression the compression used on this file.\n   * @param {number} uncompressedSize the uncompressed size to expect.\n   * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).\n   */\n  prepareContent: function (reader, from, length, compression, uncompressedSize) {\n    return function () {\n      var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n      var uncompressedFileData = compression.uncompress(compressedFileData);\n      if (uncompressedFileData.length !== uncompressedSize) {\n        throw new Error(\"Bug : uncompressed data size mismatch\");\n      }\n      return uncompressedFileData;\n    };\n  },\n  /**\n   * Read the local part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readLocalPart: function (reader) {\n    var compression, localExtraFieldsLength;\n\n    // we already know everything from the central dir !\n    // If the central dir data are false, we are doomed.\n    // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n    // The less data we get here, the more reliable this should be.\n    // Let's skip the whole header and dash to the data !\n    reader.skip(22);\n    // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n    // Strangely, the filename here is OK.\n    // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n    // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n    // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n    // the internet.\n    //\n    // I think I see the logic here : the central directory is used to display\n    // content and the local directory is used to extract the files. Mixing / and \\\n    // may be used to display \\ to windows users and use / when extracting the files.\n    // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n    this.fileNameLength = reader.readInt(2);\n    localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n    this.fileName = reader.readString(this.fileNameLength);\n    reader.skip(localExtraFieldsLength);\n    if (this.compressedSize == -1 || this.uncompressedSize == -1) {\n      throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n    }\n    compression = utils.findCompression(this.compressionMethod);\n    if (compression === null) {\n      // no compression found\n      throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + this.fileName + \")\");\n    }\n    this.decompressed = new CompressedObject();\n    this.decompressed.compressedSize = this.compressedSize;\n    this.decompressed.uncompressedSize = this.uncompressedSize;\n    this.decompressed.crc32 = this.crc32;\n    this.decompressed.compressionMethod = this.compressionMethod;\n    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\n    // we need to compute the crc32...\n    if (this.loadOptions.checkCRC32) {\n      this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n      if (jszipProto.crc32(this.decompressed) !== this.crc32) {\n        throw new Error(\"Corrupted zip : CRC32 mismatch\");\n      }\n    }\n  },\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readCentralPart: function (reader) {\n    this.versionMadeBy = reader.readString(2);\n    this.versionNeeded = reader.readInt(2);\n    this.bitFlag = reader.readInt(2);\n    this.compressionMethod = reader.readString(2);\n    this.date = reader.readDate();\n    this.crc32 = reader.readInt(4);\n    this.compressedSize = reader.readInt(4);\n    this.uncompressedSize = reader.readInt(4);\n    this.fileNameLength = reader.readInt(2);\n    this.extraFieldsLength = reader.readInt(2);\n    this.fileCommentLength = reader.readInt(2);\n    this.diskNumberStart = reader.readInt(2);\n    this.internalFileAttributes = reader.readInt(2);\n    this.externalFileAttributes = reader.readInt(4);\n    this.localHeaderOffset = reader.readInt(4);\n    if (this.isEncrypted()) {\n      throw new Error(\"Encrypted zip are not supported\");\n    }\n    this.fileName = reader.readString(this.fileNameLength);\n    this.readExtraFields(reader);\n    this.parseZIP64ExtraField(reader);\n    this.fileComment = reader.readString(this.fileCommentLength);\n\n    // warning, this is true only for zip with madeBy == DOS (plateform dependent feature)\n    this.dir = this.externalFileAttributes & 0x00000010 ? true : false;\n  },\n  /**\n   * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n   * @param {DataReader} reader the reader to use.\n   */\n  parseZIP64ExtraField: function (reader) {\n    if (!this.extraFields[0x0001]) {\n      return;\n    }\n\n    // should be something, preparing the extra reader\n    var extraReader = new StringReader(this.extraFields[0x0001].value);\n\n    // I really hope that these 64bits integer can fit in 32 bits integer, because js\n    // won't let us have more.\n    if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n      this.uncompressedSize = extraReader.readInt(8);\n    }\n    if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n      this.compressedSize = extraReader.readInt(8);\n    }\n    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n      this.localHeaderOffset = extraReader.readInt(8);\n    }\n    if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n      this.diskNumberStart = extraReader.readInt(4);\n    }\n  },\n  /**\n   * Read the central part of a zip file and add the info in this object.\n   * @param {DataReader} reader the reader to use.\n   */\n  readExtraFields: function (reader) {\n    var start = reader.index,\n      extraFieldId,\n      extraFieldLength,\n      extraFieldValue;\n    this.extraFields = this.extraFields || {};\n    while (reader.index < start + this.extraFieldsLength) {\n      extraFieldId = reader.readInt(2);\n      extraFieldLength = reader.readInt(2);\n      extraFieldValue = reader.readString(extraFieldLength);\n      this.extraFields[extraFieldId] = {\n        id: extraFieldId,\n        length: extraFieldLength,\n        value: extraFieldValue\n      };\n    }\n  },\n  /**\n   * Apply an UTF8 transformation if needed.\n   */\n  handleUTF8: function () {\n    if (this.useUTF8()) {\n      this.fileName = jszipProto.utf8decode(this.fileName);\n      this.fileComment = jszipProto.utf8decode(this.fileComment);\n    } else {\n      var upath = this.findExtraFieldUnicodePath();\n      if (upath !== null) {\n        this.fileName = upath;\n      }\n      var ucomment = this.findExtraFieldUnicodeComment();\n      if (ucomment !== null) {\n        this.fileComment = ucomment;\n      }\n    }\n  },\n  /**\n   * Find the unicode path declared in the extra field, if any.\n   * @return {String} the unicode path, null otherwise.\n   */\n  findExtraFieldUnicodePath: function () {\n    var upathField = this.extraFields[0x7075];\n    if (upathField) {\n      var extraReader = new StringReader(upathField.value);\n\n      // wrong version\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      }\n\n      // the crc of the filename changed, this field is out of date.\n      if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {\n        return null;\n      }\n      return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));\n    }\n    return null;\n  },\n  /**\n   * Find the unicode comment declared in the extra field, if any.\n   * @return {String} the unicode comment, null otherwise.\n   */\n  findExtraFieldUnicodeComment: function () {\n    var ucommentField = this.extraFields[0x6375];\n    if (ucommentField) {\n      var extraReader = new StringReader(ucommentField.value);\n\n      // wrong version\n      if (extraReader.readInt(1) !== 1) {\n        return null;\n      }\n\n      // the crc of the comment changed, this field is out of date.\n      if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {\n        return null;\n      }\n      return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));\n    }\n    return null;\n  }\n};\nmodule.exports = ZipEntry;","map":{"version":3,"names":["StringReader","require","utils","CompressedObject","jszipProto","ZipEntry","options","loadOptions","prototype","isEncrypted","bitFlag","useUTF8","prepareCompressedContent","reader","from","length","previousIndex","index","setIndex","compressedFileData","readData","prepareContent","compression","uncompressedSize","transformTo","uncompressInputType","getCompressedContent","uncompressedFileData","uncompress","Error","readLocalPart","localExtraFieldsLength","skip","fileNameLength","readInt","fileName","readString","compressedSize","findCompression","compressionMethod","pretty","decompressed","crc32","getContent","checkCRC32","readCentralPart","versionMadeBy","versionNeeded","date","readDate","extraFieldsLength","fileCommentLength","diskNumberStart","internalFileAttributes","externalFileAttributes","localHeaderOffset","readExtraFields","parseZIP64ExtraField","fileComment","dir","extraFields","extraReader","value","MAX_VALUE_32BITS","start","extraFieldId","extraFieldLength","extraFieldValue","id","handleUTF8","utf8decode","upath","findExtraFieldUnicodePath","ucomment","findExtraFieldUnicodeComment","upathField","ucommentField","module","exports"],"sources":["/Users/corneliascherrer/TecFox Projects/WebsiteVorlage/website-vorlage/node_modules/jszip/lib/zipEntry.js"],"sourcesContent":["'use strict';\nvar StringReader = require('./stringReader');\nvar utils = require('./utils');\nvar CompressedObject = require('./compressedObject');\nvar jszipProto = require('./object');\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Prepare the function used to generate the compressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).\n     */\n    prepareCompressedContent: function(reader, from, length) {\n        return function() {\n            var previousIndex = reader.index;\n            reader.setIndex(from);\n            var compressedFileData = reader.readData(length);\n            reader.setIndex(previousIndex);\n\n            return compressedFileData;\n        };\n    },\n    /**\n     * Prepare the function used to generate the uncompressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @param {JSZip.compression} compression the compression used on this file.\n     * @param {number} uncompressedSize the uncompressed size to expect.\n     * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).\n     */\n    prepareContent: function(reader, from, length, compression, uncompressedSize) {\n        return function() {\n\n            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n            var uncompressedFileData = compression.uncompress(compressedFileData);\n\n            if (uncompressedFileData.length !== uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n\n            return uncompressedFileData;\n        };\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        this.fileName = reader.readString(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize == -1 || this.uncompressedSize == -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n        }\n\n        compression = utils.findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + this.fileName + \")\");\n        }\n        this.decompressed = new CompressedObject();\n        this.decompressed.compressedSize = this.compressedSize;\n        this.decompressed.uncompressedSize = this.uncompressedSize;\n        this.decompressed.crc32 = this.crc32;\n        this.decompressed.compressionMethod = this.compressionMethod;\n        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\n        // we need to compute the crc32...\n        if (this.loadOptions.checkCRC32) {\n            this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n            if (jszipProto.crc32(this.decompressed) !== this.crc32) {\n                throw new Error(\"Corrupted zip : CRC32 mismatch\");\n            }\n        }\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readString(2);\n        this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        this.fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        this.fileName = reader.readString(this.fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readString(this.fileCommentLength);\n\n        // warning, this is true only for zip with madeBy == DOS (plateform dependent feature)\n        this.dir = this.externalFileAttributes & 0x00000010 ? true : false;\n    },\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = new StringReader(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var start = reader.index,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        this.extraFields = this.extraFields || {};\n\n        while (reader.index < start + this.extraFieldsLength) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readString(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        if (this.useUTF8()) {\n            this.fileName = jszipProto.utf8decode(this.fileName);\n            this.fileComment = jszipProto.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileName = upath;\n            }\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileComment = ucomment;\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = new StringReader(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = new StringReader(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}