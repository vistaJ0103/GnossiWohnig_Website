{"version":3,"sources":["../node_modules/focus-lock/dist/es2015/constants.js","../node_modules/use-callback-ref/dist/es2015/assignRef.js","../node_modules/use-callback-ref/dist/es2015/useMergeRef.js","../node_modules/use-callback-ref/dist/es2015/useRef.js","../node_modules/react-focus-lock/dist/es2015/FocusGuard.js","../node_modules/use-sidecar/dist/es2015/medium.js","../node_modules/react-focus-lock/dist/es2015/medium.js","../node_modules/react-focus-lock/dist/es2015/scope.js","../node_modules/react-focus-lock/dist/es2015/Lock.js","../node_modules/react-clientside-effect/lib/index.es.js","../node_modules/focus-lock/dist/es2015/utils/array.js","../node_modules/focus-lock/dist/es2015/utils/is.js","../node_modules/focus-lock/dist/es2015/utils/tabOrder.js","../node_modules/focus-lock/dist/es2015/utils/tabUtils.js","../node_modules/focus-lock/dist/es2015/utils/tabbables.js","../node_modules/focus-lock/dist/es2015/utils/DOMutils.js","../node_modules/focus-lock/dist/es2015/utils/getActiveElement.js","../node_modules/focus-lock/dist/es2015/utils/safe.js","../node_modules/focus-lock/dist/es2015/utils/all-affected.js","../node_modules/focus-lock/dist/es2015/focusInside.js","../node_modules/focus-lock/dist/es2015/commands.js","../node_modules/focus-lock/dist/es2015/utils/correctFocus.js","../node_modules/focus-lock/dist/es2015/utils/firstFocus.js","../node_modules/focus-lock/dist/es2015/solver.js","../node_modules/focus-lock/dist/es2015/utils/auto-focus.js","../node_modules/focus-lock/dist/es2015/utils/parenting.js","../node_modules/focus-lock/dist/es2015/focusSolver.js","../node_modules/focus-lock/dist/es2015/moveFocusInside.js","../node_modules/focus-lock/dist/es2015/sibling.js","../node_modules/focus-lock/dist/es2015/return-focus.js","../node_modules/react-focus-lock/dist/es2015/util.js","../node_modules/react-focus-lock/dist/es2015/Trap.js","../node_modules/focus-lock/dist/es2015/focusIsHidden.js","../node_modules/focus-lock/dist/es2015/focusables.js","../node_modules/react-focus-lock/dist/es2015/Combination.js","../node_modules/react-focus-lock/dist/es2015/index.js"],"names":["FOCUS_GROUP","FOCUS_DISABLED","assignRef","ref","value","current","useIsomorphicLayoutEffect","window","React","currentValues","WeakMap","useMergeRefs","refs","defaultValue","callbackRef","initialValue","callback","useState","facade","last","useCallbackRef","newValue","forEach","oldValue","get","prevRefs_1","Set","nextRefs_1","current_1","has","set","hiddenGuard","width","height","padding","overflow","position","top","left","InFocusGuard","_ref","_ref$children","children","key","style","propTypes","ItoI","a","innerCreateMedium","defaults","middleware","buffer","assigned","read","Error","length","useMedium","data","item","push","filter","x","assignSyncMedium","cb","cbs","assignMedium","pendingQueue","executeQueue","cycle","Promise","resolve","then","createMedium","mediumFocus","target","currentTarget","mediumBlur","mediumEffect","mediumSidecar","options","medium","__assign","async","ssr","createSidecarMedium","document","focusScope","createContext","undefined","emptyArray","FocusLock","props","parentRef","_extends2","_React$useState","realObserved","setObserved","observed","isActive","originalFocusedElement","update","_props$disabled","disabled","_props$noFocusGuards","noFocusGuards","_props$persistentFocu","persistentFocus","_props$crossFrame","crossFrame","_props$autoFocus","autoFocus","group","allowTextSelection","className","whiteList","hasPositiveIndices","_props$shards","shards","_props$as","as","Container","_props$lockProps","lockProps","containerProps","SideCar","sideCar","_props$returnFocus","returnFocus","shouldReturnFocus","focusOptions","onActivationCallback","onActivation","onDeactivationCallback","onDeactivation","id","captureFocusRestore","_document","activeElement","body","allowDefer","focusRestore","returnFocusTo","howToReturnFocus","returnFocusOptions","focus","onFocus","event","onBlur","setObserveNode","newObserved","_extends","constants","hasLeadingGuards","hasTailingGuards","mergedRef","focusScopeValue","enabled","active","tabIndex","Provider","withSideEffect","reducePropsToState","handleStateChangeOnClient","WrappedComponent","state","mountedInstances","emitChange","map","instance","SideEffect","_PureComponent","apply","this","arguments","_inheritsLoose","peek","_proto","prototype","componentDidMount","componentDidUpdate","componentWillUnmount","index","indexOf","splice","render","createElement","PureComponent","_defineProperty","displayName","name","getDisplayName","toArray","ret","Array","i","asArray","isArray","getFirst","getParentNode","node","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","isTopNode","DOCUMENT_NODE","isVisibleUncached","checkParent","ELEMENT_NODE","computedStyle","getComputedStyle","getPropertyValue","isElementHidden","hasAttribute","isInert","isVisibleCached","visibilityCache","cached","result","bind","isAutoFocusAllowedCached","cache","isAutoFocusAllowed","isAutoFocusAllowedUncached","getDataset","dataset","isHTMLInputElement","tagName","isRadioElement","type","attribute","getAttribute","includes","isGuard","_a","Boolean","focusGuard","isNotAGuard","isDefined","tabSort","b","aTab","Math","max","bTab","tabDiff","indexDiff","orderByTabIndex","nodes","filterNegative","keepGuards","getTabIndex","sort","queryTabbables","join","queryGuardTabbables","concat","getFocusablesWithShadowDom","parent","withGuards","shadowRoot","reduce","acc","child","matches","getFocusables","parents","focusableWithShadowDom","focusableWithIframes","HTMLIFrameElement","contentDocument","getFocusablesWithIFrame","querySelectorAll","filterFocusable","isHTMLButtonElement","notHiddenInput","filterAutoFocusable","Map","getTabbableNodes","topNodes","getFocusableNodes","parentAutofocusables","topNode","parentFocus","getParentAutofocusables","contains","scope","element","Object","getPrototypeOf","call","some","iframeBody","getActiveElement","inDocument","e","safeProbe","contentWindow","getTopParent","getAllAffectedNodes","currentNode","contained","l","j","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","add","DOCUMENT_POSITION_CONTAINS","_","filterNested","focusInside","ownerDocument","frame","focusInFrame","focusInsideIframe","focusOn","correctNode","el","checked","findSelectedRadio","pickFirstFocus","pickFocusable","NEW_FOCUS","newFocus","innerNodes","innerTabbables","outerNodes","lastNode","cnt","firstFocus","lastFocus","isOnGuard","activeIndex","lastIndex","lastNodeInside","firstNodeIndex","lastNodeIndex","correctedNodes","resultSet","correctNodes","correctedIndexDiff","returnFirstNode","returnLastNode","abs","pickAutofocus","nodesIndexes","orderedNodes","groups","autoFocusables","autoFocusable","autofocus","getParents","getCommonParent","nodeA","nodeB","parentsA","parentsB","currentParent","getTopCommonParent","baseActiveElement","leftEntry","rightEntries","activeElements","leftEntries","topCommon","entry","subEntry","common","allParentAutofocusables","entries","focusSolver","commonParent","anyFocusable","innerElements","orderedInnerElements","srcNodes","dstNodes","remap","entity","reorderNodes","innerFocusables","innerTabbable","newId","focusNode","console","warn","guardCount","lockDisabled","moveFocusInside","focusable","error","setTimeout","moveFocus","fromElement","newOptions","assign","onlyTabbable","defaultOptions","solution","useTabbables","every","shard","focusables","findIndex","prev","next","first","getRelativeFocusable","pickBoundary","what","getBoundary","weakRef","w","WeakRef","deref","deferAction","action","extractRef","isFreeFocus","focusIsHidden","lastActiveTrap","lastActiveFocus","lastPortaledElement","focusWasOutsideWindow","defaultWhitelist","autoGuard","startIndex","end","step","allNodes","lastGuard","guard","focusAutoGuard","lockItem","checkInHost","check","boundary","activateTrap","_lastActiveTrap","workingNode","portaledElement","workingArea","focusWhitelisted","area","withinHost","blur","querySelector","newActiveElement","expandFocusableNodes","focusedIndex","_ref2","_ref3","removeAttribute","onTrap","stopPropagation","preventDefault","source","observerNode","onWindowBlur","focusLockAPI","focusNextElement","focusPrevElement","focusFirstElement","focusLastElement","targetElement","location","stack","currentElement","parentElement","previousElementSibling","right","nextElementSibling","recordElementLocation","_b","_c","_d","_e","_i","stack_1","line","parent_1","savedCurrent","aim","_f","focusables_1","restoreFocusTo","propsList","_ref5","traps","trap","slice","addEventListener","lastTrap","sameTrap","_ref6","removeEventListener","FocusLockCombination","FocusLockUI","FocusTrap","_objectWithoutPropertiesLoose"],"mappings":"qJAGWA,EAAc,kBAIdC,EAAiB,2BCMrB,SAASC,EAAUC,EAAKC,GAO3B,MANmB,oBAARD,EACPA,EAAIC,GAECD,IACLA,EAAIE,QAAUD,GAEXD,CACX,CClBA,IAAIG,EAA8C,qBAAXC,OAAyBC,kBAAwBA,YACpFC,EAAgB,IAAIC,QAejB,SAASC,EAAaC,EAAMC,GAC/B,IAAIC,ECLD,SAAwBC,EAAcC,GACzC,IAAIb,EAAMc,oBAAS,WAAc,MAAQ,CAErCb,MAAOW,EAEPC,SAAUA,EAEVE,OAAQ,CACJ,WAAIb,GACA,OAAOF,EAAIC,KACf,EACA,WAAIC,CAAQD,GACR,IAAIe,EAAOhB,EAAIC,MACXe,IAASf,IACTD,EAAIC,MAAQA,EACZD,EAAIa,SAASZ,EAAOe,GAE5B,GAEJ,IAAG,GAGP,OADAhB,EAAIa,SAAWA,EACRb,EAAIe,MACf,CDlBsBE,CAAeP,GAAgB,MAAM,SAAUQ,GAC7D,OAAOT,EAAKU,SAAQ,SAAUnB,GAAO,OAAOD,EAAUC,EAAKkB,EAAW,GAC1E,IAqBA,OAnBAf,GAA0B,WACtB,IAAIiB,EAAWd,EAAce,IAAIV,GACjC,GAAIS,EAAU,CACV,IAAIE,EAAa,IAAIC,IAAIH,GACrBI,EAAa,IAAID,IAAId,GACrBgB,EAAYd,EAAYT,QAC5BoB,EAAWH,SAAQ,SAAUnB,GACpBwB,EAAWE,IAAI1B,IAChBD,EAAUC,EAAK,KAEvB,IACAwB,EAAWL,SAAQ,SAAUnB,GACpBsB,EAAWI,IAAI1B,IAChBD,EAAUC,EAAKyB,EAEvB,GACJ,CACAnB,EAAcqB,IAAIhB,EAAaF,EACnC,GAAG,CAACA,IACGE,CACX,CE1CO,IAAIiB,EAAc,CACvBC,MAAO,MACPC,OAAQ,MACRC,QAAS,EACTC,SAAU,SACVC,SAAU,QACVC,IAAK,MACLC,KAAM,OAEJC,EAAe,SAAsBC,GACvC,IAAIC,EAAgBD,EAAKE,SACvBA,OAA6B,IAAlBD,EAA2B,KAAOA,EAC/C,OAAoBjC,gBAAoBA,WAAgB,KAAmBA,gBAAoB,MAAO,CACpGmC,IAAK,cACL,oBAAoB,EACpB,yBAAyB,EACzBC,MAAOb,IACLW,EAAUA,GAAyBlC,gBAAoB,MAAO,CAChEmC,IAAK,aACL,oBAAoB,EACpB,yBAAyB,EACzBC,MAAOb,IAEX,EACAQ,EAAaM,UAET,CAAC,EACUN,I,QC5Bf,SAASO,EAAKC,GACV,OAAOA,CACX,CACA,SAASC,EAAkBC,EAAUC,QACd,IAAfA,IAAyBA,EAAaJ,GAC1C,IAAIK,EAAS,GACTC,GAAW,EA0Df,MAzDa,CACTC,KAAM,WACF,GAAID,EACA,MAAM,IAAIE,MAAM,oGAEpB,OAAIH,EAAOI,OACAJ,EAAOA,EAAOI,OAAS,GAE3BN,CACX,EACAO,UAAW,SAAUC,GACjB,IAAIC,EAAOR,EAAWO,EAAML,GAE5B,OADAD,EAAOQ,KAAKD,GACL,WACHP,EAASA,EAAOS,QAAO,SAAUC,GAAK,OAAOA,IAAMH,CAAM,GAC7D,CACJ,EACAI,iBAAkB,SAAUC,GAExB,IADAX,GAAW,EACJD,EAAOI,QAAQ,CAClB,IAAIS,EAAMb,EACVA,EAAS,GACTa,EAAI1C,QAAQyC,EAChB,CACAZ,EAAS,CACLQ,KAAM,SAAUE,GAAK,OAAOE,EAAGF,EAAI,EACnCD,OAAQ,WAAc,OAAOT,CAAQ,EAE7C,EACAc,aAAc,SAAUF,GACpBX,GAAW,EACX,IAAIc,EAAe,GACnB,GAAIf,EAAOI,OAAQ,CACf,IAAIS,EAAMb,EACVA,EAAS,GACTa,EAAI1C,QAAQyC,GACZG,EAAef,CACnB,CACA,IAAIgB,EAAe,WACf,IAAIH,EAAME,EACVA,EAAe,GACfF,EAAI1C,QAAQyC,EAChB,EACIK,EAAQ,WAAc,OAAOC,QAAQC,UAAUC,KAAKJ,EAAe,EACvEC,IACAjB,EAAS,CACLQ,KAAM,SAAUE,GACZK,EAAaP,KAAKE,GAClBO,GACJ,EACAR,OAAQ,SAAUA,GAEd,OADAM,EAAeA,EAAaN,OAAOA,GAC5BT,CACX,EAER,EAGR,CACO,SAASqB,EAAavB,EAAUC,GAEnC,YADmB,IAAfA,IAAyBA,EAAaJ,GACnCE,EAAkBC,EAAUC,EACvC,CCrEO,IAAIuB,EAAcD,EAAa,CAAC,GAAG,SAAUhC,GAGlD,MAAO,CACLkC,OAHWlC,EAAKkC,OAIhBC,cAHgBnC,EAAKmC,cAKzB,IACWC,EAAaJ,IACbK,EAAeL,IACfM,ED6DJ,SAA6BC,QAChB,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIC,EAAShC,EAAkB,MAE/B,OADAgC,EAAOD,QAAUE,YAAS,CAAEC,OAAO,EAAMC,KAAK,GAASJ,GAChDC,CACX,CClE2BI,CAAoB,CAC7CF,OAAO,EACPC,IAAyB,qBAAbE,WCZHC,EAA0BC,6BAAcC,GCO/CC,EAAa,GACbC,EAAyBlF,cAAiB,SAAqBmF,EAAOC,GACxE,IAAIC,EACAC,EAAkBtF,aACpBuF,EAAeD,EAAgB,GAC/BE,EAAcF,EAAgB,GAC5BG,EAAWzF,WACX0F,EAAW1F,UAAa,GACxB2F,EAAyB3F,SAAa,MAExC4F,EADqB5F,WAAe,CAAC,GACX,GACxBkC,EAAWiD,EAAMjD,SACnB2D,EAAkBV,EAAMW,SACxBA,OAA+B,IAApBD,GAAqCA,EAChDE,EAAuBZ,EAAMa,cAC7BA,OAAyC,IAAzBD,GAA0CA,EAC1DE,EAAwBd,EAAMe,gBAC9BA,OAA4C,IAA1BD,GAA2CA,EAC7DE,EAAoBhB,EAAMiB,WAC1BA,OAAmC,IAAtBD,GAAsCA,EACnDE,EAAmBlB,EAAMmB,UACzBA,OAAiC,IAArBD,GAAqCA,EAEjDE,GADqBpB,EAAMqB,mBACnBrB,EAAMoB,OACdE,EAAYtB,EAAMsB,UAClBC,EAAYvB,EAAMuB,UAClBC,EAAqBxB,EAAMwB,mBAC3BC,EAAgBzB,EAAM0B,OACtBA,OAA2B,IAAlBD,EAA2B3B,EAAa2B,EACjDE,EAAY3B,EAAM4B,GAClBC,OAA0B,IAAdF,EAAuB,MAAQA,EAC3CG,EAAmB9B,EAAM+B,UACzBC,OAAsC,IAArBF,EAA8B,CAAC,EAAIA,EACpDG,EAAUjC,EAAMkC,QAChBC,EAAqBnC,EAAMoC,YAC3BC,OAA2C,IAAvBF,GAAwCA,EAC5DG,EAAetC,EAAMsC,aACrBC,EAAuBvC,EAAMwC,aAC7BC,EAAyBzC,EAAM0C,eAE/BC,EADqB9H,WAAe,CAAC,GACf,GACpB2H,EAAe3H,eAAkB,SAAUgC,GAC7C,IAAI+F,EAAsB/F,EAAK+F,oBAC/B,IAAKpC,EAAuB9F,QAAS,CACnC,IAAImI,EACAC,EAA0C,OAAzBD,EAAYnD,eAAoB,EAASmD,EAAUC,cACxEtC,EAAuB9F,QAAUoI,EAC7BA,IAAkBpD,SAASqD,OAC7BvC,EAAuB9F,QAAUkI,EAAoBE,GAEzD,CACIxC,EAAS5F,SAAW6H,GACtBA,EAAqBjC,EAAS5F,SAEhC6F,EAAS7F,SAAU,EACnB+F,GACF,GAAG,CAAC8B,IACAG,EAAiB7H,eAAkB,WACrC0F,EAAS7F,SAAU,EACf+H,GACFA,EAAuBnC,EAAS5F,SAElC+F,GACF,GAAG,CAACgC,IACAL,EAAcvH,eAAkB,SAAUmI,GAC5C,IAAIC,EAAezC,EAAuB9F,QAC1C,GAAIuI,EAAc,CAChB,IAAIC,GAAyC,oBAAjBD,EAA8BA,IAAiBA,IAAiBvD,SAASqD,KACjGI,EAAgD,oBAAtBd,EAAmCA,EAAkBa,GAAiBb,EACpG,GAAIc,EAAkB,CACpB,IAAIC,EAAiD,kBAArBD,EAAgCA,OAAmBtD,EACnFW,EAAuB9F,QAAU,KAC7BsI,EACFtE,QAAQC,UAAUC,MAAK,WACrB,OAAOsE,EAAcG,MAAMD,EAC7B,IAEAF,EAAcG,MAAMD,EAExB,CACF,CACF,GAAG,CAACf,IACAiB,EAAUzI,eAAkB,SAAU0I,GACpChD,EAAS7F,SACXoE,EAAYjB,UAAU0F,EAE1B,GAAG,IACCC,EAASvE,EAAWpB,UACpB4F,GAAiB5I,eAAkB,SAAU6I,GAC3CpD,EAAS5F,UAAYgJ,IACvBpD,EAAS5F,QAAUgJ,EACnBrD,EAAYqD,GAEhB,GAAG,IAWH,IAAI3B,GAAY4B,cAAUzD,EAAY,CAAC,GAAa0D,GAA4BjD,GAAY,WAAYT,EAAU0D,GAAyBxC,EAAOlB,GAAY8B,GAC1J6B,IAAqC,IAAlBhD,EACnBiD,GAAmBD,IAAsC,SAAlBhD,EACvCkD,GAAY/I,EAAa,CAACiF,EAAWwD,KACrCO,GAAkBnJ,WAAc,WAClC,MAAO,CACLyF,SAAUA,EACVoB,OAAQA,EACRuC,SAAUtD,EACVuD,OAAQ3D,EAAS7F,QAErB,GAAG,CAACiG,EAAUJ,EAAS7F,QAASgH,EAAQtB,IACxC,OAAoBvF,gBAAoBA,WAAgB,KAAMgJ,IAAoB,CAElFhJ,gBAAoB,MAAO,CACzBmC,IAAK,cACL,oBAAoB,EACpBmH,SAAUxD,GAAY,EAAI,EAC1B1D,MAAOb,IACLoF,EAAkC3G,gBAAoB,MAAO,CAC/DmC,IAAK,gBACL,oBAAoB,EACpBmH,SAAUxD,GAAY,EAAI,EAC1B1D,MAAOb,IACJ,OAAQuE,GAAyB9F,gBAAoBoH,EAAS,CACjEU,GAAIA,EACJT,QAAS/C,EACTmB,SAAUF,EACVO,SAAUA,EACVI,gBAAiBA,EACjBE,WAAYA,EACZE,UAAWA,EACXI,UAAWA,EACXG,OAAQA,EACRc,aAAcA,EACdE,eAAgBA,EAChBN,YAAaA,EACbE,aAAcA,IACCzH,gBAAoBgH,EAAW8B,YAAS,CACvDnJ,IAAKuJ,IACJhC,GAAW,CACZT,UAAWA,EACXkC,OAAQA,EACRF,QAASA,IACMzI,gBAAoB8E,EAAWyE,SAAU,CACxD3J,MAAOuJ,IACNjH,IAAY+G,IAAiCjJ,gBAAoB,MAAO,CACzE,oBAAoB,EACpBsJ,SAAUxD,GAAY,EAAI,EAC1B1D,MAAOb,IAEX,IACA2D,EAAU7C,UAoBN,CAAC,EACU6C,Q,eC3GAsE,MA1Ef,SAAwBC,EAAoBC,GAe1C,OAAO,SAAcC,GAOnB,IACIC,EADAC,EAAmB,GAGvB,SAASC,IACPF,EAAQH,EAAmBI,EAAiBE,KAAI,SAAUC,GACxD,OAAOA,EAAS7E,KAClB,KACAuE,EAA0BE,EAC5B,CAEA,IAAIK,EAA0B,SAAUC,GAGtC,SAASD,IACP,OAAOC,EAAeC,MAAMC,KAAMC,YAAcD,IAClD,CAJAE,YAAeL,EAAYC,GAO3BD,EAAWM,KAAO,WAChB,OAAOX,CACT,EAEA,IAAIY,EAASP,EAAWQ,UAqBxB,OAnBAD,EAAOE,kBAAoB,WACzBb,EAAiB1G,KAAKiH,MACtBN,GACF,EAEAU,EAAOG,mBAAqB,WAC1Bb,GACF,EAEAU,EAAOI,qBAAuB,WAC5B,IAAIC,EAAQhB,EAAiBiB,QAAQV,MACrCP,EAAiBkB,OAAOF,EAAO,GAC/Bf,GACF,EAEAU,EAAOQ,OAAS,WACd,OAAoBhL,IAAMiL,cAActB,EAAkBS,KAAKjF,MACjE,EAEO8E,CACT,CAlC8B,CAkC5BiB,iBAIF,OAFAC,YAAgBlB,EAAY,cAAe,cAzD7C,SAAwBN,GACtB,OAAOA,EAAiByB,aAAezB,EAAiB0B,MAAQ,WAClE,CAuD6DC,CAAe3B,GAAoB,KAEvFM,CACT,CACF,ECzEWsB,EAAU,SAAUhJ,GAE3B,IADA,IAAIiJ,EAAMC,MAAMlJ,EAAEQ,QACT2I,EAAI,EAAGA,EAAInJ,EAAEQ,SAAU2I,EAC5BF,EAAIE,GAAKnJ,EAAEmJ,GAEf,OAAOF,CACX,EACWG,EAAU,SAAUpJ,GAAK,OAAQkJ,MAAMG,QAAQrJ,GAAKA,EAAI,CAACA,EAAK,EAC9DsJ,EAAW,SAAUtJ,GAAK,OAAQkJ,MAAMG,QAAQrJ,GAAKA,EAAE,GAAKA,CAAI,ECEvEuJ,EAAgB,SAAUC,GAE1B,OAAOA,EAAKC,YAAcD,EAAKC,WAAWC,WAAaC,KAAKC,uBAEpDJ,EAAKC,WAAWI,KAClBL,EAAKC,UACf,EACIK,EAAY,SAAUN,GAEtB,OAAOA,IAASlH,UAAakH,GAAQA,EAAKE,WAAaC,KAAKI,aAChE,EAKIC,EAAoB,SAAUR,EAAMS,GACpC,OAAQT,GAAQM,EAAUN,KA5BR,SAAUA,GAG5B,GAAIA,EAAKE,WAAaC,KAAKO,aACvB,OAAO,EAEX,IAAIC,EAAgB3M,OAAO4M,iBAAiBZ,EAAM,MAClD,SAAKW,IAAkBA,EAAcE,oBAGiB,SAA9CF,EAAcE,iBAAiB,YAA0E,WAAjDF,EAAcE,iBAAiB,cACnG,CAiByCC,CAAgBd,KAL3C,SAAUA,GAAQ,OAAOA,EAAKe,aAAa,QAAU,CAKAC,CAAQhB,IAASS,EAAYV,EAAcC,GAC9G,EACWiB,EAAkB,SAAUC,EAAiBlB,GACpD,IAAImB,EAASD,EAAgBjM,IAAI+K,GACjC,QAAe/G,IAAXkI,EACA,OAAOA,EAEX,IAAIC,EAASZ,EAAkBR,EAAMiB,EAAgBI,UAAKpI,EAAWiI,IAErE,OADAA,EAAgB3L,IAAIyK,EAAMoB,GACnBA,CACX,EAIWE,EAA2B,SAAUC,EAAOvB,GACnD,IAAImB,EAASI,EAAMtM,IAAI+K,GACvB,QAAe/G,IAAXkI,EACA,OAAOA,EAEX,IAAIC,EARyB,SAAUpB,EAAMS,GAC7C,QAAOT,IAASM,EAAUN,OAASwB,EAAmBxB,IAAQS,EAAYV,EAAcC,GAC5F,CAMiByB,CAA2BzB,EAAMsB,EAAyBD,UAAKpI,EAAWsI,IAEvF,OADAA,EAAMhM,IAAIyK,EAAMoB,GACTA,CACX,EACWM,EAAa,SAAU1B,GAE9B,OAAOA,EAAK2B,OAChB,EAEWC,EAAqB,SAAU5B,GAAQ,MAAwB,UAAjBA,EAAK6B,OAAqB,EACxEC,EAAiB,SAAU9B,GAClC,OAAO4B,EAAmB5B,IAAuB,UAAdA,EAAK+B,IAC5C,EAIWP,EAAqB,SAAUxB,GACtC,IAAIgC,EAAYhC,EAAKiC,aX5CO,qBW6C5B,OAAQ,EAAC,EAAM,OAAQ,IAAIC,SAASF,EACxC,EACWG,EAAU,SAAUnC,GAAQ,IAAIoC,EAAI,OAAOC,QAAQrC,IAAqC,QAA3BoC,EAAKV,EAAW1B,UAA0B,IAAPoC,OAAgB,EAASA,EAAGE,YAAc,EAC1IC,EAAc,SAAUvC,GAAQ,OAAQmC,EAAQnC,EAAO,EACvDwC,EAAY,SAAUlL,GAAK,OAAO+K,QAAQ/K,EAAI,ECrE9CmL,EAAU,SAAUjM,EAAGkM,GAC9B,IAAIC,EAAOC,KAAKC,IAAI,EAAGrM,EAAE+G,UACrBuF,EAAOF,KAAKC,IAAI,EAAGH,EAAEnF,UACrBwF,EAAUJ,EAAOG,EACjBE,EAAYxM,EAAEsI,MAAQ4D,EAAE5D,MAC5B,GAAIiE,EAAS,CACT,IAAKJ,EACD,OAAO,EAEX,IAAKG,EACD,OAAQ,CAEhB,CACA,OAAOC,GAAWC,CACtB,EAYWC,EAAkB,SAAUC,EAAOC,EAAgBC,GAC1D,OAAO5D,EAAQ0D,GACVlF,KAAI,SAAUgC,EAAMlB,GACrB,IAAIvB,EAdM,SAAUyC,GACxB,OAAIA,EAAKzC,SAAW,IAIXyC,EAAKe,aAAa,YACZ,EAGRf,EAAKzC,QAChB,CAIuB8F,CAAYrD,GAC3B,MAAO,CACHA,KAAMA,EACNlB,MAAOA,EACPvB,SAAU6F,IAA4B,IAAd7F,GAAoByC,EAAK2B,SAAW,CAAC,GAAGW,WAAa,GAAK,EAAK/E,EAE/F,IACKlG,QAAO,SAAUH,GAAQ,OAAQiM,GAAkBjM,EAAKqG,UAAY,CAAG,IACvE+F,KAAKb,EACd,ECpCIc,ECAmB,CACnB,iBACA,iBACA,mBACA,gBAGA,UACA,aACA,UACA,SACA,SACA,QACA,kBACA,kBACA,aACA,oBACA,eDjB2BC,KAAK,KAChCC,EAAsB,GAAGC,OAAOH,EAAgB,wBAChDI,EAA6B,SAAUC,EAAQC,GAC/C,OAAOrE,GAASoE,EAAOE,YAAcF,GAAQzN,UAAU4N,QAAO,SAAUC,EAAKC,GACzE,OAAOD,EAAIN,OAAOO,EAAMC,QAAQL,EAAaJ,EAAsBF,GAAkB,CAACU,GAAS,GAAIN,EAA2BM,GAClI,GAAG,GACP,EASWE,EAAgB,SAAUC,EAASP,GAC1C,OAAOO,EAAQL,QAAO,SAAUC,EAAKJ,GACjC,IAAIxB,EACAiC,EAAyBV,EAA2BC,EAAQC,GAC5DS,GAAwBlC,EAAK,IAAIsB,OAAOtF,MAAMgE,EAAIiC,EAAuBrG,KAAI,SAAUgC,GAAQ,OAZ7E,SAAU4D,EAAQC,GAC5C,IAAIzB,EAEJ,OAAIwB,aAAkBW,oBAAwD,QAAjCnC,EAAKwB,EAAOY,uBAAoC,IAAPpC,OAAgB,EAASA,EAAGjG,MACvGgI,EAAc,CAACP,EAAOY,gBAAgBrI,MAAO0H,GAEjD,CAACD,EACZ,CAKkHa,CAAwBzE,EAAM6D,EAAa,KACrJ,OAAOG,EAAIN,OAEXY,EAEAV,EAAO3D,WACDT,EAAQoE,EAAO3D,WAAWyE,iBAAiBnB,IAAiBlM,QAAO,SAAU2I,GAAQ,OAAOA,IAAS4D,CAAQ,IAC7G,GACV,GAAG,GACP,EEtBWe,EAAkB,SAAUzB,EAAOhC,GAC1C,OAAO1B,EAAQ0D,GACV7L,QAAO,SAAU2I,GAAQ,OAAOiB,EAAgBC,EAAiBlB,EAAO,IACxE3I,QAAO,SAAU2I,GAAQ,OJiDN,SAAUA,GAClC,SAAU4B,EAAmB5B,IANA,SAAUA,GAAQ,MAAwB,WAAjBA,EAAK6B,OAAsB,CAM3C+C,CAAoB5E,MAAyB,WAAdA,EAAK+B,MAAqB/B,EAAKjG,UACxG,CInDyC8K,CAAe7E,EAAO,GAC/D,EACW8E,EAAsB,SAAU5B,EAAO3B,GAE9C,YADc,IAAVA,IAAoBA,EAAQ,IAAIwD,KAC7BvF,EAAQ0D,GAAO7L,QAAO,SAAU2I,GAAQ,OAAOsB,EAAyBC,EAAOvB,EAAO,GACjG,EAUWgF,EAAmB,SAAUC,EAAU/D,EAAiB2C,GAC/D,OAAOZ,EAAgB0B,EAAgBR,EAAcc,EAAUpB,GAAa3C,IAAkB,EAAM2C,EACxG,EAYWqB,GAAoB,SAAUD,EAAU/D,GAC/C,OAAO+B,EAAgB0B,EAAgBR,EAAcc,GAAW/D,IAAkB,EACtF,EAMWiE,GAAuB,SAAUC,EAASlE,GACjD,OAAOyD,EFd0B,SAAUf,GAC3C,IAAIyB,EAAczB,EAAOc,iBAAiB,IAAIhB,ObrB1B,wBaqB6C,MACjE,OAAOlE,EAAQ6F,GACVrH,KAAI,SAAUgC,GAAQ,OAAOmE,EAAc,CAACnE,GAAQ,IACpD+D,QAAO,SAAUC,EAAKd,GAAS,OAAOc,EAAIN,OAAOR,EAAQ,GAAG,GACrE,CES2BoC,CAAwBF,GAAUlE,EAC7D,EAIWqE,GAAW,SAAUC,EAAOC,GACnC,OAAID,EAAM1B,WACCyB,GAASC,EAAM1B,WAAY2B,UAGYxM,IAA1CyM,OAAOC,eAAeH,GAAOD,WAC7BG,OAAOC,eAAeH,GAAOD,SAASK,KAAKJ,EAAOC,KAG/CjG,EAAQgG,EAAMrP,UAAU0P,MAAK,SAAU5B,GAC1C,IAAI7B,EACJ,GAAI6B,aAAiBM,kBAAmB,CACpC,IAAIuB,EAA8C,QAAhC1D,EAAK6B,EAAMO,uBAAoC,IAAPpC,OAAgB,EAASA,EAAGjG,KACtF,QAAI2J,GACOP,GAASO,EAAYL,EAGpC,CACA,OAAOF,GAAStB,EAAOwB,EAC3B,GAER,ECpEWM,GAAmB,SAAUC,GAEpC,QADmB,IAAfA,IAAyBA,EAAalN,UACrCkN,GAAeA,EAAW9J,cAA/B,CAGA,IAAIA,EAAgB8J,EAAW9J,cAC/B,OAAQA,EAAc4H,WAChBiC,GAAiB7J,EAAc4H,YAC/B5H,aAAyBqI,mBChBZ,SAAU/M,GAC7B,IACI,OAAOA,GACX,CACA,MAAOyO,GACH,MACJ,CACJ,CDSwDC,EAAU,WAAc,OAAOhK,EAAciK,cAAcrN,QAAU,IAC/GiN,GAAiB7J,EAAciK,cAAcrN,UAC7CoD,CANV,CAOJ,EEaIkK,GAAe,SAAUpG,GACzB,OAAOA,EAAKC,WAAamG,GAAapG,EAAKC,YAAcD,CAC7D,EAMWqG,GAAsB,SAAUrG,GAEvC,OADYJ,EAAQI,GACP3I,OAAOgL,SAAS0B,QAAO,SAAUC,EAAKsC,GAC/C,IAAI9L,EAAQ8L,EAAYrE,aAAaxO,GAIrC,OAHAuQ,EAAI5M,KAAKgH,MAAM4F,EAAMxJ,EAnCV,SAAU0I,GAGzB,IAFA,IAAIqD,EAAY,IAAIpR,IAChBqR,EAAItD,EAAMlM,OACL2I,EAAI,EAAGA,EAAI6G,EAAG7G,GAAK,EACxB,IAAK,IAAI8G,EAAI9G,EAAI,EAAG8G,EAAID,EAAGC,GAAK,EAAG,CAC/B,IAAI5Q,EAAWqN,EAAMvD,GAAG+G,wBAAwBxD,EAAMuD,KAEjD5Q,EAAWsK,KAAKwG,gCAAkC,GACnDJ,EAAUK,IAAIH,IAEb5Q,EAAWsK,KAAK0G,4BAA8B,GAC/CN,EAAUK,IAAIjH,EAGtB,CAEJ,OAAOuD,EAAM7L,QAAO,SAAUyP,EAAGhI,GAAS,OAAQyH,EAAUjR,IAAIwJ,EAAQ,GAC5E,CAmBciI,CAAavH,EAAQ4G,GAAaE,GAAa5B,iBAAiB,IAAIhB,OAAOjQ,EAAa,MAAOiQ,OAAOlJ,EAAO,YAAakJ,OAAOhQ,EAAgB,oBACjJ,CAAC4S,IACAtC,CACX,GAAG,GACP,ECrCWgD,GAAc,SAAU5B,EAASlJ,GAGxC,YADsB,IAAlBA,IAA4BA,EAAgB6J,GAAiBjG,EAASsF,GAAS6B,mBAC9E/K,GAAkBA,EAAcyF,SAAWzF,EAAcyF,QAAQW,aAG/D+D,GAAoBjB,GAASS,MAAK,SAAU7F,GAC/C,OAAOuF,GAASvF,EAAM9D,IAdN,SAAUkJ,EAASlJ,GACvC,OAAOmG,QAAQ7C,EAAQ4F,EAAQV,iBAAiB,WAAWmB,MAAK,SAAU7F,GAAQ,OAFnE,SAAUkH,EAAOhL,GAAiB,OAAOgL,IAAUhL,CAAe,CAEQiL,CAAanH,EAAM9D,EAAgB,IAChI,CAYgDkL,CAAkBpH,EAAM9D,EACpE,GACJ,ECrBWmL,GAAU,SAAUlP,EAAQuD,GAC9BvD,IAID,UAAWA,GACXA,EAAOsE,MAAMf,GAEb,kBAAmBvD,GAAUA,EAAOgO,eACpChO,EAAOgO,cAAc1J,QAE7B,ECJW6K,GAAc,SAAUtH,EAAMkD,GACrC,OAAIpB,EAAe9B,IAASA,EAAKV,KAPb,SAAUU,EAAMkD,GACpC,OAAOA,EACF7L,OAAOyK,GACPzK,QAAO,SAAUkQ,GAAM,OAAOA,EAAGjI,OAASU,EAAKV,IAAM,IACrDjI,QAAO,SAAUkQ,GAAM,OAAOA,EAAGC,OAAS,IAAG,IAAMxH,CAC5D,CAGeyH,CAAkBzH,EAAMkD,GAE5BlD,CACX,ECXW0H,GAAiB,SAAUxE,GAClC,OAAIA,EAAM,IAAMA,EAAMlM,OAAS,EACpBsQ,GAAYpE,EAAM,GAAIA,GAE1BA,EAAM,EACjB,EACWyE,GAAgB,SAAUzE,EAAOlD,GACxC,OAAOkD,EAAMnE,QAAQuI,GAAYtH,EAAMkD,GAC3C,ECNW0E,GAAY,YAUZC,GAAW,SAAUC,EAAYC,EAAgBC,EAAY9L,EAAe+L,GACnF,IAAIC,EAAMJ,EAAW9Q,OACjBmR,EAAaL,EAAW,GACxBM,EAAYN,EAAWI,EAAM,GAC7BG,EAAYlG,EAAQjG,GAExB,KAAIA,GAAiB4L,EAAW/I,QAAQ7C,IAAkB,GAA1D,CAGA,IAAIoM,OAAgCrP,IAAlBiD,EAA8B8L,EAAWjJ,QAAQ7C,IAAkB,EACjFqM,EAAYN,EAAWD,EAAWjJ,QAAQkJ,GAAYK,EACtDE,EAAiBP,EAAWH,EAAW/I,QAAQkJ,IAAa,EAEhE,IAAqB,IAAjBK,EAEA,OAAwB,IAApBE,EACOA,EAEJZ,GAGX,IAAwB,IAApBY,EACA,OAAOZ,GAEX,IAAI5E,EAAYsF,EAAcC,EAC1BE,EAAiBT,EAAWjJ,QAAQoJ,GACpCO,EAAgBV,EAAWjJ,QAAQqJ,GACnCO,EFvBkB,SAAUzF,GAEhC,IAAI0F,EAAY,IAAIzT,IAGpB,OAFA+N,EAAMnO,SAAQ,SAAUiL,GAAQ,OAAO4I,EAAUhC,IAAIU,GAAYtH,EAAMkD,GAAS,IAEzEA,EAAM7L,QAAO,SAAU2I,GAAQ,OAAO4I,EAAUtT,IAAI0K,EAAO,GACtE,CEiByB6I,CAAab,GAE9Bc,QADmC7P,IAAlBiD,EAA8ByM,EAAe5J,QAAQ7C,IAAkB,IACjD+L,EAAWU,EAAe5J,QAAQkJ,GAAYK,GAEzF,IAAKtF,GAAawF,GAAkB,EAChC,OAAOA,EAGX,GAA8B,IAA1BT,EAAe/Q,OAIf,OAAOwR,EAEX,IAAIO,EAAkBpB,GAAcG,EAAYC,EAAe,IAC3DiB,EAAiBrB,GAAcG,EAAYC,EAAeA,EAAe/Q,OAAS,IAEtF,OAAIsR,GAAeG,GAAkBJ,GAAazF,KAAKqG,IAAIjG,GAAa,EAC7DgG,EAGPV,GAAeI,GAAiBL,GAAazF,KAAKqG,IAAIjG,GAAa,EAC5D+F,EAGP/F,GAAaJ,KAAKqG,IAAIH,GAAsB,EACrCN,EAGPF,GAAeG,EACRO,EAGPV,EAAcI,EACPK,EAGP/F,EACIJ,KAAKqG,IAAIjG,GAAa,EACfwF,GAEHN,EAAMM,EAAiBxF,GAAakF,OAJhD,CAxDA,CAgEJ,ECrEWgB,GAAgB,SAAUC,EAAcC,EAAcC,GAC7D,IAd4BC,EAcxBpG,EAAQiG,EAAanL,KAAI,SAAUoE,GAEnC,OADWA,EAAGpC,IAElB,IACIuJ,EAAgBzE,EAAoB5B,EAAM7L,QAlBlBiS,EAkByCD,EAjB9D,SAAUrJ,GACb,IAAIoC,EACAoH,EAAwC,QAA3BpH,EAAKV,EAAW1B,UAA0B,IAAPoC,OAAgB,EAASA,EAAGoH,UAChF,OAEAxJ,EAAKwJ,gBAEcvQ,IAAduQ,GAAyC,UAAdA,GAE5BF,EAAevK,QAAQiB,IAAS,CACxC,KAQA,OAAIuJ,GAAiBA,EAAcvS,OACxB0Q,GAAe6B,GAEnB7B,GAAe5C,EAAoBsE,GAC9C,ECvBIK,GAAa,SAAUzJ,EAAMoE,GAM7B,YALgB,IAAZA,IAAsBA,EAAU,IACpCA,EAAQhN,KAAK4I,GACTA,EAAKC,YACLwJ,GAAWzJ,EAAKC,WAAWI,MAAQL,EAAKC,WAAYmE,GAEjDA,CACX,EAOWsF,GAAkB,SAAUC,EAAOC,GAI1C,IAHA,IAAIC,EAAWJ,GAAWE,GACtBG,EAAWL,GAAWG,GAEjBjK,EAAI,EAAGA,EAAIkK,EAAS7S,OAAQ2I,GAAK,EAAG,CACzC,IAAIoK,EAAgBF,EAASlK,GAC7B,GAAImK,EAAS/K,QAAQgL,IAAkB,EACnC,OAAOA,CAEf,CACA,OAAO,CACX,EACWC,GAAqB,SAAUC,EAAmBC,EAAWC,GACpE,IAAIC,EAAiBxK,EAAQqK,GACzBI,EAAczK,EAAQsK,GACtBhO,EAAgBkO,EAAe,GAC/BE,GAAY,EAgBhB,OAfAD,EAAYhT,OAAOgL,SAAStN,SAAQ,SAAUwV,GAC1CD,EAAYZ,GAAgBY,GAAaC,EAAOA,IAAUD,EAC1DH,EAAa9S,OAAOgL,SAAStN,SAAQ,SAAUyV,GAC3C,IAAIC,EAASf,GAAgBxN,EAAesO,GACxCC,IAEIH,GADCA,GAAa/E,GAASkF,EAAQH,GACnBG,EAGAf,GAAgBe,EAAQH,GAGhD,GACJ,IAEOA,CACX,EAMWI,GAA0B,SAAUC,EAASzJ,GACpD,OAAOyJ,EAAQ5G,QAAO,SAAUC,EAAKhE,GAAQ,OAAOgE,EAAIN,OAAOyB,GAAqBnF,EAAMkB,GAAmB,GAAG,GACpH,ECjCW0J,GAAc,SAAUxF,EAAS6C,GACxC,IAAI/L,EAAgB6J,GAAiBnG,EAAQwF,GAASpO,OAAS,EAAI8B,SAAWgH,EAASsF,GAAS6B,eAC5F0D,EAAUtE,GAAoBjB,GAAS/N,OAAOkL,GAC9CsI,EAAeb,GAAmB9N,GAAiBkJ,EAASA,EAASuF,GACrEzJ,EAAkB,IAAI6D,IACtB+F,EAAe5F,GAAkByF,EAASzJ,GAC1C6J,EAAgBD,EAAazT,QAAO,SAAU+K,GAC9C,IAAIpC,EAAOoC,EAAGpC,KACd,OAAOuC,EAAYvC,EACvB,IACA,GAAK+K,EAAc,GAAnB,CAGA,IAAI/C,EAAa9C,GAAkB,CAAC2F,GAAe3J,GAAiBlD,KAAI,SAAUoE,GAE9E,OADWA,EAAGpC,IAElB,IACIgL,EAlCW,SAAUC,EAAUC,GACnC,IAAIC,EAAQ,IAAIpG,IAIhB,OAFAmG,EAASnW,SAAQ,SAAUqW,GAAU,OAAOD,EAAM5V,IAAI6V,EAAOpL,KAAMoL,EAAS,IAErEH,EAASjN,KAAI,SAAUgC,GAAQ,OAAOmL,EAAMlW,IAAI+K,EAAO,IAAG3I,OAAOmL,EAC5E,CA4B+B6I,CAAarD,EAAY+C,GAEhDO,EAAkBN,EAAqBhN,KAAI,SAAUoE,GAErD,OADWA,EAAGpC,IAElB,IACIuL,EAAgBP,EAAqB3T,QAAO,SAAU+K,GAEtD,OADeA,EAAG7E,UACC,CACvB,IAAGS,KAAI,SAAUoE,GAEb,OADWA,EAAGpC,IAElB,IACIwL,EAAQ3D,GAASyD,EAAiBC,EAAevD,EAAY9L,EAAe+L,GAChF,GAAIuD,IAAU5D,GAAW,CACrB,IAAI6D,EAEJvC,GAAc4B,EAAcS,EAAeb,GAAwBC,EAASzJ,KACxEgI,GAAc4B,EAAcQ,EAAiBZ,GAAwBC,EAASzJ,IAClF,OAAIuK,EACO,CAAEzL,KAAMyL,QAGfC,QAAQC,KAAK,sDAGrB,CACA,YAAc1S,IAAVuS,EACOA,EAEJR,EAAqBQ,EAnC5B,CAoCJ,ECvEII,GAAa,EACbC,IAAe,EAaRC,GAAkB,SAAU1G,EAAS6C,EAAUzP,QACtC,IAAZA,IAAsBA,EAAU,CAAC,GACrC,IAAIuT,EAAYnB,GAAYxF,EAAS6C,GAErC,IAAI4D,IAGAE,EAAW,CAEX,GAAIH,GAAa,EAQb,OANAF,QAAQM,MAAM,qJAEdH,IAAe,OACfI,YAAW,WACPJ,IAAe,CACnB,GAAG,GAGPD,KACAvE,GAAQ0E,EAAU/L,KAAMxH,EAAQkD,cAChCkQ,IACJ,CACJ,ECeIM,GAAY,SAAUC,EAAa3T,EAAShB,QAC5B,IAAZgB,IAAsBA,EAAU,CAAC,GACrC,IAAI4T,EATa,SAAU5T,GAC3B,OAAOkN,OAAO2G,OAAO,CACjB7G,MAAO1M,SAASqD,KAChBtE,OAAO,EACPyU,cAAc,GACf9T,EACP,CAGqB+T,CAAe/T,GAC5BgU,EA/C0B,SAAU/G,EAASD,EAAOiH,GACxD,IAAKhH,IAAYD,EAEb,OADAkG,QAAQM,MAAM,6BACP,CAAC,EAEZ,IAAIlR,EAAS8E,EAAQ4F,GACrB,GAAI1K,EAAO4R,OAAM,SAAUC,GAAS,OAAQpH,GAASoH,EAAOlH,EAAU,IAElE,OADAiG,QAAQM,MAAM,gDACP,CAAC,EAEZ,IAAIY,EAAaH,EACXzH,EAAiBlK,EAAQ,IAAIiK,KAC7BG,GAAkBpK,EAAQ,IAAIiK,KAChCjR,EAAU8Y,EAAWC,WAAU,SAAUzK,GAEzC,OADWA,EAAGpC,OACEyF,CACpB,IACA,OAAiB,IAAb3R,EAIG,CACHgZ,KAAMF,EAAW9Y,EAAU,GAC3BiZ,KAAMH,EAAW9Y,EAAU,GAC3BkZ,MAAOJ,EAAW,GAClBhY,KAAMgY,EAAWA,EAAW5V,OAAS,SARzC,CAUJ,CAoBmBiW,CAAqBd,EAAaC,EAAW5G,MAAO4G,EAAWE,cAC9E,GAAKE,EAAL,CAGA,IAAIrU,EAASX,EAAGgV,EAAUJ,EAAWvU,OACjCM,GACAkP,GAAQlP,EAAO6H,KAAMoM,EAAW1Q,aAHpC,CAKJ,EAyBIwR,GAAe,SAAU1H,EAAOhN,EAAS2U,GACzC,IAAI/K,EAEApC,EAvDU,SAAUlF,EAAQ2R,GAChC,IAAIlX,EAAMkX,EACJzH,EAAiBpF,EAAQ9E,GAAS,IAAIiK,KACtCG,GAAkBtF,EAAQ9E,GAAS,IAAIiK,KAC7C,MAAO,CACHiI,MAAOzX,EAAI,GACXX,KAAMW,EAAIA,EAAIyB,OAAS,GAE/B,CA8CmBoW,CAAY5H,EAAuC,QAA/BpD,EAAK5J,EAAQ8T,oBAAiC,IAAPlK,GAAgBA,GACtE+K,GAChBnN,GACAqH,GAAQrH,EAAKA,KAAMxH,EAAQkD,aAEnC,EChGA,SAAS2R,GAAQxZ,GACb,IAAKA,EACD,OAAO,KACX,IAAIyZ,EAAIzZ,EAAQ,IAAI0Z,QAAQ1Z,GAAS,KACrC,OAAO,WAAc,OAAc,OAANyZ,QAAoB,IAANA,OAAe,EAASA,EAAEE,UAAY,IAAM,CAC3F,CCNO,SAASC,GAAYC,GAC1BzB,WAAWyB,EAAQ,EACrB,CACO,IAKIC,GAAa,SAAoB/Z,GAC1C,OAAOA,GAAO,YAAaA,EAAMA,EAAIE,QAAUF,CACjD,ECDIga,GAAc,WAChB,OAHO9U,UAAYA,SAASoD,gBAAkBpD,SAASqD,MCK9B,SAAU6J,QACd,IAAfA,IAAyBA,EAAalN,UAC1C,IAAIoD,EAAgB6J,GAAiBC,GACrC,QAAK9J,GAIEsD,EAAQwG,EAAWtB,iBAAiB,IAAIhB,OhCR1B,qBgCQ8C,OAAOmC,MAAK,SAAU7F,GAAQ,OAAOuF,GAASvF,EAAM9D,EAAgB,GAC3I,CDV0B2R,EAC1B,EACIC,GAAiB,KACjBC,GAAkB,KAClBC,GAAsB,KACtBC,IAAwB,EACxBC,GAAmB,WACrB,OAAO,CACT,EAaA,SAASC,GAAUC,EAAYC,EAAKC,EAAMC,GACxC,IAAIC,EAAY,KACZ7O,EAAIyO,EACR,EAAG,CACD,IAAIjX,EAAOoX,EAAS5O,GACpB,GAAIxI,EAAKsX,MACHtX,EAAK6I,KAAK2B,QAAQ+M,iBACpBF,EAAYrX,OAET,KAAIA,EAAKwX,SAMd,MALA,GAAIhP,IAAMyO,EACR,OAEFI,EAAY,IAGd,CACF,QAAU7O,GAAK2O,KAAUD,GACrBG,IACFA,EAAUxO,KAAKzC,SAAW,EAE9B,CACA,IAMIqR,GAAc,SAASA,EAAYC,EAAOtH,EAAIuH,GAChD,OAAOvH,IAAOA,EAAGlH,OAASwO,KAAWtH,EAAGrL,eAAiB4S,EAASvJ,SAASgC,EAAGrL,iBAAmBqL,EAAGtH,YAAc2O,EAAYC,EAAOtH,EAAGtH,WAAY6O,GACtJ,EAMIC,GAAe,WACjB,IAxCqDtJ,EAwCjDrE,GAAS,EACb,GAAI0M,GAAgB,CAClB,IAAIkB,EAAkBlB,GACpBpU,EAAWsV,EAAgBtV,SAC3BS,EAAkB6U,EAAgB7U,gBAClCI,EAAYyU,EAAgBzU,UAC5BO,EAASkU,EAAgBlU,OACzBT,EAAa2U,EAAgB3U,WAC7BqB,EAAesT,EAAgBtT,aAC7BuT,EAAcvV,GAAYsU,IAAuBA,GAAoBkB,gBACrEhT,EAAgBpD,UAAYA,SAASoD,cACzC,GAAI+S,EAAa,CACf,IAAIE,EAAc,CAACF,GAAavL,OAAO5I,EAAOkD,IAAI2P,IAAYtW,OAAOgL,UAoBrE,GAnBKnG,IA9DY,SAA0BA,GAC/C,OAAQ4R,GAAenT,WAAauT,IAAkBhS,EACxD,CA4D4BkT,CAAiBlT,KACjC/B,IAAmCE,EA3BpCgI,QAAQ4L,IAEgB,cAA1BA,MAyBsDL,OAAkBG,IAAmBxT,KACtF0U,KAAiBjI,GAAYmI,IAAgBjT,GArB1C,SAAoBA,EAAeiT,GAClD,OAAOA,EAAYtJ,MAAK,SAAUwJ,GAChC,OAAOT,GAAY1S,EAAemT,EAAMA,EAC1C,GACF,CAiB4EC,CAAWpT,EAAeiT,KAvD/C1J,EAuDmFvJ,EAtDjI8R,IAAuBA,GAAoBkB,kBAAoBzJ,MAuDxD3M,WAAaiV,IAAmB7R,IAAkB3B,GAChD2B,EAAcqT,MAChBrT,EAAcqT,OAEhBzW,SAASqD,KAAKM,UAEd2E,EAAS0K,GAAgBqD,EAAapB,GAAiB,CACrDrS,aAAcA,IAEhBsS,GAAsB,CAAC,IAG3BC,IAAwB,EACxBF,GAAkBjV,UAAYA,SAASoD,eAGvCpD,UAAYoD,IAAkBpD,SAASoD,eAAiBpD,SAAS0W,cAAc,2BAA4B,CAC7G,IAAIC,EAAmB3W,UAAYA,SAASoD,cACxCqS,EE3FsB,SAAUnJ,GACxC,IAAIuF,EAAUtE,GAAoBjB,GAAS/N,OAAOkL,GAC9CsI,EAAeb,GAAmB5E,EAASA,EAASuF,GACpD3C,EAAa/E,EAAgBkB,EAAc,CAAC0G,IAAe,IAAO,GAAM,GACxEE,EAAgB5G,EAAcwG,GAAS,GAC3C,OAAO3C,EAAWhK,KAAI,SAAUoE,GAC5B,IAAIpC,EAAOoC,EAAGpC,KACd,MAAQ,CACJA,KAAMA,EACNlB,MAHwBsD,EAAGtD,MAI3B6P,SAAU5D,EAAchM,QAAQiB,IAAS,EACzCyO,MAAOtM,EAAQnC,GAEvB,GACJ,CF6EuB0P,CAAqBP,GAChCQ,EAAepB,EAASvQ,KAAI,SAAU/H,GAExC,OADWA,EAAK+J,IAElB,IAAGjB,QAAQ0Q,GACPE,GAAgB,IAClBpB,EAASlX,QAAO,SAAUuY,GACxB,IAAInB,EAAQmB,EAAMnB,MAChBzO,EAAO4P,EAAM5P,KACf,OAAOyO,GAASzO,EAAK2B,QAAQ+M,cAC/B,IAAG3Z,SAAQ,SAAU8a,GAEnB,OADWA,EAAM7P,KACL8P,gBAAgB,WAC9B,IACA3B,GAAUwB,EAAcpB,EAASvX,OAAQ,EAAIuX,GAC7CJ,GAAUwB,GAAe,GAAI,EAAGpB,GAEpC,CACF,CACF,CACA,OAAOnN,CACT,EACI2O,GAAS,SAAgBpT,GACvBoS,MAAkBpS,IACpBA,EAAMqT,kBACNrT,EAAMsT,iBAEV,EACIrT,GAAS,WACX,OAAO6Q,GAAYsB,GACrB,EACIrS,GAAU,SAAiBC,GAC7B,IAAIuT,EAASvT,EAAMxE,OACfmO,EAAc3J,EAAMvE,cACnBkO,EAAYf,SAAS2K,KAjH1BlC,GAAsB,CACpBmC,aAiHa7J,EAhHb4I,gBAgH0BgB,GAE9B,EAcIE,GAAe,WACjBnC,GAAwB,OACxBR,IAAY,WACVQ,GAAwB,WAC1B,GACF,EAiBA,IAAIoC,GAAe,CACjBvE,gBAAiBA,GACjB9E,YAAaA,GACbsJ,iBH3G4B,SAAUnE,EAAa3T,QACjC,IAAZA,IAAsBA,EAAU,CAAC,GACrC0T,GAAUC,EAAa3T,GAAS,SAAU4J,EAAIvK,GAC1C,IAAIkV,EAAO3K,EAAG2K,KAAMC,EAAQ5K,EAAG4K,MAC/B,OAAOD,GAASlV,GAASmV,CAC7B,GACJ,EGsGEuD,iBHhG4B,SAAUpE,EAAa3T,QACjC,IAAZA,IAAsBA,EAAU,CAAC,GACrC0T,GAAUC,EAAa3T,GAAS,SAAU4J,EAAIvK,GAC1C,IAAIiV,EAAO1K,EAAG0K,KAAMlY,EAAOwN,EAAGxN,KAC9B,OAAOkY,GAASjV,GAASjD,CAC7B,GACJ,EG2FE4b,kBH9E6B,SAAUhL,EAAOhN,QAC5B,IAAZA,IAAsBA,EAAU,CAAC,GACrC0U,GAAa1H,EAAOhN,EAAS,QACjC,EG4EEiY,iBHvE4B,SAAUjL,EAAOhN,QAC3B,IAAZA,IAAsBA,EAAU,CAAC,GACrC0U,GAAa1H,EAAOhN,EAAS,OACjC,EGqEEwD,oBFvG+B,SAAU0U,GACvC,IAAIC,EAzE2B,SAAUlL,GACzC,IAAKA,EACD,OAAO,KAIX,IAFA,IAAImL,EAAQ,GACRC,EAAiBpL,EACdoL,GAAkBA,IAAmB/X,SAASqD,MACjDyU,EAAMxZ,KAAK,CACPtD,QAASuZ,GAAQwD,GACjBjN,OAAQyJ,GAAQwD,EAAeC,eAC/B/a,KAAMsX,GAAQwD,EAAeE,wBAC7BC,MAAO3D,GAAQwD,EAAeI,sBAElCJ,EAAiBA,EAAeC,cAEpC,MAAO,CACHrL,QAAS4H,GAAQ5H,GACjBmL,MAAOA,EACP3J,cAAexB,EAAQwB,cAE/B,CAqDmBiK,CAAsBR,GACrC,OAAO,WACH,OAtDa,SAAUC,GAC3B,IAAIvO,EAAI+O,EAAIC,EAAIC,EAAIC,EACpB,GAAKX,EAKL,IAFA,IAAIC,EAAQD,EAASC,MAAO3J,EAAgB0J,EAAS1J,cACjD/F,EAAkB,IAAI6D,IACjBwM,EAAK,EAAGC,EAAUZ,EAAOW,EAAKC,EAAQxa,OAAQua,IAAM,CACzD,IAAIE,EAAOD,EAAQD,GACfG,EAAkC,QAAtBtP,EAAKqP,EAAK7N,cAA2B,IAAPxB,OAAgB,EAASA,EAAGwD,KAAK6L,GAE/E,GAAIC,GAAYzK,EAAc1B,SAASmM,GAAW,CAe9C,IAdA,IAAI3b,EAA4B,QAApBob,EAAKM,EAAK1b,YAAyB,IAAPob,OAAgB,EAASA,EAAGvL,KAAK6L,GACrEE,EAAeF,EAAK3d,UACpBA,EAAU4d,EAASnM,SAASoM,GAAgBA,OAAe1Y,EAC3D+X,EAA8B,QAArBI,EAAKK,EAAKT,aAA0B,IAAPI,OAAgB,EAASA,EAAGxL,KAAK6L,GACvE7E,EAAa5H,EAAiB,CAAC0M,GAAWxQ,GAC1C0Q,EAMO,QAJVN,EAEwE,QAFlED,EAAiB,OAAZvd,QAAgC,IAAZA,EAAqBA,EAE5C,OAATiC,QAA0B,IAATA,OAAkB,EAASA,EAAKkb,0BAAuC,IAAPI,EAAgBA,EAEjGL,SAA0B,IAAPM,EAAgBA,EAEnCvb,EACO6b,GAAK,CACR,IAAK,IAAIC,EAAK,EAAGC,EAAelF,EAAYiF,EAAKC,EAAa9a,OAAQ6a,IAAM,CACxE,IAAI9F,EAAY+F,EAAaD,GAC7B,GAAY,OAARD,QAAwB,IAARA,OAAiB,EAASA,EAAIrM,SAASwG,EAAU/L,MACjE,OAAO+L,EAAU/L,IAEzB,CACA4R,EAAMA,EAAIX,kBACd,CACA,GAAIrE,EAAW5V,OAEX,OAAO4V,EAAW,GAAG5M,IAE7B,CACJ,CAGJ,CAWe+R,CAAepB,EAC1B,CACJ,GEiIAzY,EAAYX,iBAAiBmF,IAC7BrE,EAAWX,aAAakF,IACxBtE,EAAaZ,cAAa,SAAUF,GAClC,OAAOA,EAAG6Y,GACZ,IACe5S,UAjDf,SAA4BuU,GAC1B,OAAOA,EAAU3a,QAAO,SAAU4a,GAEhC,OADeA,EAAMlY,QAEvB,GACF,IAUA,SAAmCmY,GACjC,IAAIC,EAAOD,EAAME,OAAO,GAAG,GACvBD,IAASrE,KA1BbhV,SAASuZ,iBAAiB,UAAWtC,IACrCjX,SAASuZ,iBAAiB,WAAYzV,IACtC5I,OAAOqe,iBAAiB,OAAQjC,KA2BhC,IAAIkC,EAAWxE,GACXyE,EAAWD,GAAYH,GAAQA,EAAKpW,KAAOuW,EAASvW,GACxD+R,GAAiBqE,EACbG,IAAaC,IACfD,EAASxW,iBACJoW,EAAM7a,QAAO,SAAUmb,GAE1B,OADSA,EAAMzW,KACDuW,EAASvW,EACzB,IAAG/E,QACDsb,EAAS9W,aAAa2W,IAGtBA,GACFpE,GAAkB,KACbwE,GAAYD,EAAS5Y,WAAayY,EAAKzY,UAC1CyY,EAAKvW,aAAayU,IAEpBtB,KACAtB,GAAYsB,MA1CdjW,SAAS2Z,oBAAoB,UAAW1C,IACxCjX,SAAS2Z,oBAAoB,WAAY7V,IACzC5I,OAAOye,oBAAoB,OAAQrC,IA2CjCrC,GAAkB,KAEtB,GAMetQ,EA9EI,WACjB,OAAO,IACT,IGzIIiV,GAAoCze,cAAiB,SAAgCmF,EAAOxF,GAC9F,OAAoBK,gBAAoB0e,EAAa5V,YAAS,CAC5DzB,QAASsX,GACThf,IAAKA,GACJwF,GACL,IACInD,GAAO0c,EAAYrc,WAAa,CAAC,EACzBL,GAAKqF,QACHuX,YAA8B5c,GAAM,CAAC,YACnDyc,GAAqBpc,UAAgE,CAAC,EACvEoc,UCbAvZ,M","file":"static/js/14.04144111.chunk.js","sourcesContent":["/**\n * defines a focus group\n */\nexport var FOCUS_GROUP = 'data-focus-lock';\n/**\n * disables element discovery inside a group marked by key\n */\nexport var FOCUS_DISABLED = 'data-focus-lock-disabled';\n/**\n * allows uncontrolled focus within the marked area, effectively disabling focus lock for it's content\n */\nexport var FOCUS_ALLOW = 'data-no-focus-lock';\n/**\n * instructs autofocus engine to pick default autofocus inside a given node\n * can be set on the element or container\n */\nexport var FOCUS_AUTO = 'data-autofocus-inside';\n/**\n * instructs autofocus to ignore elements within a given node\n * can be set on the element or container\n */\nexport var FOCUS_NO_AUTOFOCUS = 'data-no-autofocus';\n","/**\n * Assigns a value for a given ref, no matter of the ref format\n * @param {RefObject} ref - a callback function or ref object\n * @param value - a new value\n *\n * @see https://github.com/theKashey/use-callback-ref#assignref\n * @example\n * const refObject = useRef();\n * const refFn = (ref) => {....}\n *\n * assignRef(refObject, \"refValue\");\n * assignRef(refFn, \"refValue\");\n */\nexport function assignRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    }\n    else if (ref) {\n        ref.current = value;\n    }\n    return ref;\n}\n","import * as React from 'react';\nimport { assignRef } from './assignRef';\nimport { useCallbackRef } from './useRef';\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar currentValues = new WeakMap();\n/**\n * Merges two or more refs together providing a single interface to set their value\n * @param {RefObject|Ref} refs\n * @returns {MutableRefObject} - a new ref, which translates all changes to {refs}\n *\n * @see {@link mergeRefs} a version without buit-in memoization\n * @see https://github.com/theKashey/use-callback-ref#usemergerefs\n * @example\n * const Component = React.forwardRef((props, ref) => {\n *   const ownRef = useRef();\n *   const domRef = useMergeRefs([ref, ownRef]); // 👈 merge together\n *   return <div ref={domRef}>...</div>\n * }\n */\nexport function useMergeRefs(refs, defaultValue) {\n    var callbackRef = useCallbackRef(defaultValue || null, function (newValue) {\n        return refs.forEach(function (ref) { return assignRef(ref, newValue); });\n    });\n    // handle refs changes - added or removed\n    useIsomorphicLayoutEffect(function () {\n        var oldValue = currentValues.get(callbackRef);\n        if (oldValue) {\n            var prevRefs_1 = new Set(oldValue);\n            var nextRefs_1 = new Set(refs);\n            var current_1 = callbackRef.current;\n            prevRefs_1.forEach(function (ref) {\n                if (!nextRefs_1.has(ref)) {\n                    assignRef(ref, null);\n                }\n            });\n            nextRefs_1.forEach(function (ref) {\n                if (!prevRefs_1.has(ref)) {\n                    assignRef(ref, current_1);\n                }\n            });\n        }\n        currentValues.set(callbackRef, refs);\n    }, [refs]);\n    return callbackRef;\n}\n","import { useState } from 'react';\n/**\n * creates a MutableRef with ref change callback\n * @param initialValue - initial ref value\n * @param {Function} callback - a callback to run when value changes\n *\n * @example\n * const ref = useCallbackRef(0, (newValue, oldValue) => console.log(oldValue, '->', newValue);\n * ref.current = 1;\n * // prints 0 -> 1\n *\n * @see https://reactjs.org/docs/hooks-reference.html#useref\n * @see https://github.com/theKashey/use-callback-ref#usecallbackref---to-replace-reactuseref\n * @returns {MutableRefObject}\n */\nexport function useCallbackRef(initialValue, callback) {\n    var ref = useState(function () { return ({\n        // value\n        value: initialValue,\n        // last callback\n        callback: callback,\n        // \"memoized\" public interface\n        facade: {\n            get current() {\n                return ref.value;\n            },\n            set current(value) {\n                var last = ref.value;\n                if (last !== value) {\n                    ref.value = value;\n                    ref.callback(value, last);\n                }\n            },\n        },\n    }); })[0];\n    // update callback\n    ref.callback = callback;\n    return ref.facade;\n}\n","import * as React from 'react';\nimport PropTypes from 'prop-types';\nexport var hiddenGuard = {\n  width: '1px',\n  height: '0px',\n  padding: 0,\n  overflow: 'hidden',\n  position: 'fixed',\n  top: '1px',\n  left: '1px'\n};\nvar InFocusGuard = function InFocusGuard(_ref) {\n  var _ref$children = _ref.children,\n    children = _ref$children === void 0 ? null : _ref$children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n    key: \"guard-first\",\n    \"data-focus-guard\": true,\n    \"data-focus-auto-guard\": true,\n    style: hiddenGuard\n  }), children, children && /*#__PURE__*/React.createElement(\"div\", {\n    key: \"guard-last\",\n    \"data-focus-guard\": true,\n    \"data-focus-auto-guard\": true,\n    style: hiddenGuard\n  }));\n};\nInFocusGuard.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: PropTypes.node\n} : {};\nexport default InFocusGuard;","import { __assign } from \"tslib\";\nfunction ItoI(a) {\n    return a;\n}\nfunction innerCreateMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    var buffer = [];\n    var assigned = false;\n    var medium = {\n        read: function () {\n            if (assigned) {\n                throw new Error('Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.');\n            }\n            if (buffer.length) {\n                return buffer[buffer.length - 1];\n            }\n            return defaults;\n        },\n        useMedium: function (data) {\n            var item = middleware(data, assigned);\n            buffer.push(item);\n            return function () {\n                buffer = buffer.filter(function (x) { return x !== item; });\n            };\n        },\n        assignSyncMedium: function (cb) {\n            assigned = true;\n            while (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n            }\n            buffer = {\n                push: function (x) { return cb(x); },\n                filter: function () { return buffer; },\n            };\n        },\n        assignMedium: function (cb) {\n            assigned = true;\n            var pendingQueue = [];\n            if (buffer.length) {\n                var cbs = buffer;\n                buffer = [];\n                cbs.forEach(cb);\n                pendingQueue = buffer;\n            }\n            var executeQueue = function () {\n                var cbs = pendingQueue;\n                pendingQueue = [];\n                cbs.forEach(cb);\n            };\n            var cycle = function () { return Promise.resolve().then(executeQueue); };\n            cycle();\n            buffer = {\n                push: function (x) {\n                    pendingQueue.push(x);\n                    cycle();\n                },\n                filter: function (filter) {\n                    pendingQueue = pendingQueue.filter(filter);\n                    return buffer;\n                },\n            };\n        },\n    };\n    return medium;\n}\nexport function createMedium(defaults, middleware) {\n    if (middleware === void 0) { middleware = ItoI; }\n    return innerCreateMedium(defaults, middleware);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function createSidecarMedium(options) {\n    if (options === void 0) { options = {}; }\n    var medium = innerCreateMedium(null);\n    medium.options = __assign({ async: true, ssr: false }, options);\n    return medium;\n}\n","import { createMedium, createSidecarMedium } from 'use-sidecar';\nexport var mediumFocus = createMedium({}, function (_ref) {\n  var target = _ref.target,\n    currentTarget = _ref.currentTarget;\n  return {\n    target: target,\n    currentTarget: currentTarget\n  };\n});\nexport var mediumBlur = createMedium();\nexport var mediumEffect = createMedium();\nexport var mediumSidecar = createSidecarMedium({\n  async: true,\n  ssr: typeof document !== 'undefined'\n});","import { createContext } from 'react';\nexport var focusScope = /*#__PURE__*/createContext(undefined);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { node, bool, string, any, arrayOf, oneOfType, object, func } from 'prop-types';\nimport * as constants from 'focus-lock/constants';\nimport { useMergeRefs } from 'use-callback-ref';\nimport { hiddenGuard } from './FocusGuard';\nimport { mediumFocus, mediumBlur, mediumSidecar } from './medium';\nimport { focusScope } from './scope';\nvar emptyArray = [];\nvar FocusLock = /*#__PURE__*/React.forwardRef(function FocusLockUI(props, parentRef) {\n  var _extends2;\n  var _React$useState = React.useState(),\n    realObserved = _React$useState[0],\n    setObserved = _React$useState[1];\n  var observed = React.useRef();\n  var isActive = React.useRef(false);\n  var originalFocusedElement = React.useRef(null);\n  var _React$useState2 = React.useState({}),\n    update = _React$useState2[1];\n  var children = props.children,\n    _props$disabled = props.disabled,\n    disabled = _props$disabled === void 0 ? false : _props$disabled,\n    _props$noFocusGuards = props.noFocusGuards,\n    noFocusGuards = _props$noFocusGuards === void 0 ? false : _props$noFocusGuards,\n    _props$persistentFocu = props.persistentFocus,\n    persistentFocus = _props$persistentFocu === void 0 ? false : _props$persistentFocu,\n    _props$crossFrame = props.crossFrame,\n    crossFrame = _props$crossFrame === void 0 ? true : _props$crossFrame,\n    _props$autoFocus = props.autoFocus,\n    autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus,\n    allowTextSelection = props.allowTextSelection,\n    group = props.group,\n    className = props.className,\n    whiteList = props.whiteList,\n    hasPositiveIndices = props.hasPositiveIndices,\n    _props$shards = props.shards,\n    shards = _props$shards === void 0 ? emptyArray : _props$shards,\n    _props$as = props.as,\n    Container = _props$as === void 0 ? 'div' : _props$as,\n    _props$lockProps = props.lockProps,\n    containerProps = _props$lockProps === void 0 ? {} : _props$lockProps,\n    SideCar = props.sideCar,\n    _props$returnFocus = props.returnFocus,\n    shouldReturnFocus = _props$returnFocus === void 0 ? false : _props$returnFocus,\n    focusOptions = props.focusOptions,\n    onActivationCallback = props.onActivation,\n    onDeactivationCallback = props.onDeactivation;\n  var _React$useState3 = React.useState({}),\n    id = _React$useState3[0];\n  var onActivation = React.useCallback(function (_ref) {\n    var captureFocusRestore = _ref.captureFocusRestore;\n    if (!originalFocusedElement.current) {\n      var _document;\n      var activeElement = (_document = document) == null ? void 0 : _document.activeElement;\n      originalFocusedElement.current = activeElement;\n      if (activeElement !== document.body) {\n        originalFocusedElement.current = captureFocusRestore(activeElement);\n      }\n    }\n    if (observed.current && onActivationCallback) {\n      onActivationCallback(observed.current);\n    }\n    isActive.current = true;\n    update();\n  }, [onActivationCallback]);\n  var onDeactivation = React.useCallback(function () {\n    isActive.current = false;\n    if (onDeactivationCallback) {\n      onDeactivationCallback(observed.current);\n    }\n    update();\n  }, [onDeactivationCallback]);\n  var returnFocus = React.useCallback(function (allowDefer) {\n    var focusRestore = originalFocusedElement.current;\n    if (focusRestore) {\n      var returnFocusTo = (typeof focusRestore === 'function' ? focusRestore() : focusRestore) || document.body;\n      var howToReturnFocus = typeof shouldReturnFocus === 'function' ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;\n      if (howToReturnFocus) {\n        var returnFocusOptions = typeof howToReturnFocus === 'object' ? howToReturnFocus : undefined;\n        originalFocusedElement.current = null;\n        if (allowDefer) {\n          Promise.resolve().then(function () {\n            return returnFocusTo.focus(returnFocusOptions);\n          });\n        } else {\n          returnFocusTo.focus(returnFocusOptions);\n        }\n      }\n    }\n  }, [shouldReturnFocus]);\n  var onFocus = React.useCallback(function (event) {\n    if (isActive.current) {\n      mediumFocus.useMedium(event);\n    }\n  }, []);\n  var onBlur = mediumBlur.useMedium;\n  var setObserveNode = React.useCallback(function (newObserved) {\n    if (observed.current !== newObserved) {\n      observed.current = newObserved;\n      setObserved(newObserved);\n    }\n  }, []);\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof allowTextSelection !== 'undefined') {\n      console.warn('React-Focus-Lock: allowTextSelection is deprecated and enabled by default');\n    }\n    React.useEffect(function () {\n      if (!observed.current && typeof Container !== 'string') {\n        console.error('FocusLock: could not obtain ref to internal node');\n      }\n    }, []);\n  }\n  var lockProps = _extends((_extends2 = {}, _extends2[constants.FOCUS_DISABLED] = disabled && 'disabled', _extends2[constants.FOCUS_GROUP] = group, _extends2), containerProps);\n  var hasLeadingGuards = noFocusGuards !== true;\n  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== 'tail';\n  var mergedRef = useMergeRefs([parentRef, setObserveNode]);\n  var focusScopeValue = React.useMemo(function () {\n    return {\n      observed: observed,\n      shards: shards,\n      enabled: !disabled,\n      active: isActive.current\n    };\n  }, [disabled, isActive.current, shards, realObserved]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, hasLeadingGuards && [\n  /*#__PURE__*/\n  React.createElement(\"div\", {\n    key: \"guard-first\",\n    \"data-focus-guard\": true,\n    tabIndex: disabled ? -1 : 0,\n    style: hiddenGuard\n  }), hasPositiveIndices ? /*#__PURE__*/React.createElement(\"div\", {\n    key: \"guard-nearest\",\n    \"data-focus-guard\": true,\n    tabIndex: disabled ? -1 : 1,\n    style: hiddenGuard\n  }) : null], !disabled && /*#__PURE__*/React.createElement(SideCar, {\n    id: id,\n    sideCar: mediumSidecar,\n    observed: realObserved,\n    disabled: disabled,\n    persistentFocus: persistentFocus,\n    crossFrame: crossFrame,\n    autoFocus: autoFocus,\n    whiteList: whiteList,\n    shards: shards,\n    onActivation: onActivation,\n    onDeactivation: onDeactivation,\n    returnFocus: returnFocus,\n    focusOptions: focusOptions\n  }), /*#__PURE__*/React.createElement(Container, _extends({\n    ref: mergedRef\n  }, lockProps, {\n    className: className,\n    onBlur: onBlur,\n    onFocus: onFocus\n  }), /*#__PURE__*/React.createElement(focusScope.Provider, {\n    value: focusScopeValue\n  }, children)), hasTailingGuards && /*#__PURE__*/React.createElement(\"div\", {\n    \"data-focus-guard\": true,\n    tabIndex: disabled ? -1 : 0,\n    style: hiddenGuard\n  }));\n});\nFocusLock.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: node,\n  disabled: bool,\n  returnFocus: oneOfType([bool, object, func]),\n  focusOptions: object,\n  noFocusGuards: bool,\n  hasPositiveIndices: bool,\n  allowTextSelection: bool,\n  autoFocus: bool,\n  persistentFocus: bool,\n  crossFrame: bool,\n  group: string,\n  className: string,\n  whiteList: func,\n  shards: arrayOf(any),\n  as: oneOfType([string, func, object]),\n  lockProps: object,\n  onActivation: func,\n  onDeactivation: func,\n  sideCar: any.isRequired\n} : {};\nexport default FocusLock;","import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport React, { PureComponent } from 'react';\n\nfunction withSideEffect(reducePropsToState, handleStateChangeOnClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof reducePropsToState !== 'function') {\n      throw new Error('Expected reducePropsToState to be a function.');\n    }\n\n    if (typeof handleStateChangeOnClient !== 'function') {\n      throw new Error('Expected handleStateChangeOnClient to be a function.');\n    }\n  }\n\n  function getDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  }\n\n  return function wrap(WrappedComponent) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof WrappedComponent !== 'function') {\n        throw new Error('Expected WrappedComponent to be a React component.');\n      }\n    }\n\n    var mountedInstances = [];\n    var state;\n\n    function emitChange() {\n      state = reducePropsToState(mountedInstances.map(function (instance) {\n        return instance.props;\n      }));\n      handleStateChangeOnClient(state);\n    }\n\n    var SideEffect = /*#__PURE__*/function (_PureComponent) {\n      _inheritsLoose(SideEffect, _PureComponent);\n\n      function SideEffect() {\n        return _PureComponent.apply(this, arguments) || this;\n      }\n\n      // Try to use displayName of wrapped component\n      SideEffect.peek = function peek() {\n        return state;\n      };\n\n      var _proto = SideEffect.prototype;\n\n      _proto.componentDidMount = function componentDidMount() {\n        mountedInstances.push(this);\n        emitChange();\n      };\n\n      _proto.componentDidUpdate = function componentDidUpdate() {\n        emitChange();\n      };\n\n      _proto.componentWillUnmount = function componentWillUnmount() {\n        var index = mountedInstances.indexOf(this);\n        mountedInstances.splice(index, 1);\n        emitChange();\n      };\n\n      _proto.render = function render() {\n        return /*#__PURE__*/React.createElement(WrappedComponent, this.props);\n      };\n\n      return SideEffect;\n    }(PureComponent);\n\n    _defineProperty(SideEffect, \"displayName\", \"SideEffect(\" + getDisplayName(WrappedComponent) + \")\");\n\n    return SideEffect;\n  };\n}\n\nexport default withSideEffect;\n","/*\nIE11 support\n */\nexport var toArray = function (a) {\n    var ret = Array(a.length);\n    for (var i = 0; i < a.length; ++i) {\n        ret[i] = a[i];\n    }\n    return ret;\n};\nexport var asArray = function (a) { return (Array.isArray(a) ? a : [a]); };\nexport var getFirst = function (a) { return (Array.isArray(a) ? a[0] : a); };\n","import { FOCUS_NO_AUTOFOCUS } from '../constants';\nvar isElementHidden = function (node) {\n    // we can measure only \"elements\"\n    // consider others as \"visible\"\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n        return false;\n    }\n    var computedStyle = window.getComputedStyle(node, null);\n    if (!computedStyle || !computedStyle.getPropertyValue) {\n        return false;\n    }\n    return (computedStyle.getPropertyValue('display') === 'none' || computedStyle.getPropertyValue('visibility') === 'hidden');\n};\nvar getParentNode = function (node) {\n    // DOCUMENT_FRAGMENT_NODE can also point on ShadowRoot. In this case .host will point on the next node\n    return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE\n        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            node.parentNode.host\n        : node.parentNode;\n};\nvar isTopNode = function (node) {\n    // @ts-ignore\n    return node === document || (node && node.nodeType === Node.DOCUMENT_NODE);\n};\nvar isInert = function (node) { return node.hasAttribute('inert'); };\n/**\n * @see https://github.com/testing-library/jest-dom/blob/main/src/to-be-visible.js\n */\nvar isVisibleUncached = function (node, checkParent) {\n    return !node || isTopNode(node) || (!isElementHidden(node) && !isInert(node) && checkParent(getParentNode(node)));\n};\nexport var isVisibleCached = function (visibilityCache, node) {\n    var cached = visibilityCache.get(node);\n    if (cached !== undefined) {\n        return cached;\n    }\n    var result = isVisibleUncached(node, isVisibleCached.bind(undefined, visibilityCache));\n    visibilityCache.set(node, result);\n    return result;\n};\nvar isAutoFocusAllowedUncached = function (node, checkParent) {\n    return node && !isTopNode(node) ? (isAutoFocusAllowed(node) ? checkParent(getParentNode(node)) : false) : true;\n};\nexport var isAutoFocusAllowedCached = function (cache, node) {\n    var cached = cache.get(node);\n    if (cached !== undefined) {\n        return cached;\n    }\n    var result = isAutoFocusAllowedUncached(node, isAutoFocusAllowedCached.bind(undefined, cache));\n    cache.set(node, result);\n    return result;\n};\nexport var getDataset = function (node) {\n    // @ts-ignore\n    return node.dataset;\n};\nexport var isHTMLButtonElement = function (node) { return node.tagName === 'BUTTON'; };\nexport var isHTMLInputElement = function (node) { return node.tagName === 'INPUT'; };\nexport var isRadioElement = function (node) {\n    return isHTMLInputElement(node) && node.type === 'radio';\n};\nexport var notHiddenInput = function (node) {\n    return !((isHTMLInputElement(node) || isHTMLButtonElement(node)) && (node.type === 'hidden' || node.disabled));\n};\nexport var isAutoFocusAllowed = function (node) {\n    var attribute = node.getAttribute(FOCUS_NO_AUTOFOCUS);\n    return ![true, 'true', ''].includes(attribute);\n};\nexport var isGuard = function (node) { var _a; return Boolean(node && ((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.focusGuard)); };\nexport var isNotAGuard = function (node) { return !isGuard(node); };\nexport var isDefined = function (x) { return Boolean(x); };\n","import { toArray } from './array';\nexport var tabSort = function (a, b) {\n    var aTab = Math.max(0, a.tabIndex);\n    var bTab = Math.max(0, b.tabIndex);\n    var tabDiff = aTab - bTab;\n    var indexDiff = a.index - b.index;\n    if (tabDiff) {\n        if (!aTab) {\n            return 1;\n        }\n        if (!bTab) {\n            return -1;\n        }\n    }\n    return tabDiff || indexDiff;\n};\nvar getTabIndex = function (node) {\n    if (node.tabIndex < 0) {\n        // all \"focusable\" elements are already preselected\n        // but some might have implicit negative tabIndex\n        // return 0 for <audio without tabIndex attribute - it is \"tabbable\"\n        if (!node.hasAttribute('tabindex')) {\n            return 0;\n        }\n    }\n    return node.tabIndex;\n};\nexport var orderByTabIndex = function (nodes, filterNegative, keepGuards) {\n    return toArray(nodes)\n        .map(function (node, index) {\n        var tabIndex = getTabIndex(node);\n        return {\n            node: node,\n            index: index,\n            tabIndex: keepGuards && tabIndex === -1 ? ((node.dataset || {}).focusGuard ? 0 : -1) : tabIndex,\n        };\n    })\n        .filter(function (data) { return !filterNegative || data.tabIndex >= 0; })\n        .sort(tabSort);\n};\n","import { FOCUS_AUTO } from '../constants';\nimport { toArray } from './array';\nimport { tabbables } from './tabbables';\nvar queryTabbables = tabbables.join(',');\nvar queryGuardTabbables = \"\".concat(queryTabbables, \", [data-focus-guard]\");\nvar getFocusablesWithShadowDom = function (parent, withGuards) {\n    return toArray((parent.shadowRoot || parent).children).reduce(function (acc, child) {\n        return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));\n    }, []);\n};\nvar getFocusablesWithIFrame = function (parent, withGuards) {\n    var _a;\n    // contentDocument of iframe will be null if current origin cannot access it\n    if (parent instanceof HTMLIFrameElement && ((_a = parent.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        return getFocusables([parent.contentDocument.body], withGuards);\n    }\n    return [parent];\n};\nexport var getFocusables = function (parents, withGuards) {\n    return parents.reduce(function (acc, parent) {\n        var _a;\n        var focusableWithShadowDom = getFocusablesWithShadowDom(parent, withGuards);\n        var focusableWithIframes = (_a = []).concat.apply(_a, focusableWithShadowDom.map(function (node) { return getFocusablesWithIFrame(node, withGuards); }));\n        return acc.concat(\n        // add all tabbables inside and within shadow DOMs in DOM order\n        focusableWithIframes, \n        // add if node is tabbable itself\n        parent.parentNode\n            ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function (node) { return node === parent; })\n            : []);\n    }, []);\n};\n/**\n * return a list of focusable nodes within an area marked as \"auto-focusable\"\n * @param parent\n */\nexport var getParentAutofocusables = function (parent) {\n    var parentFocus = parent.querySelectorAll(\"[\".concat(FOCUS_AUTO, \"]\"));\n    return toArray(parentFocus)\n        .map(function (node) { return getFocusables([node]); })\n        .reduce(function (acc, nodes) { return acc.concat(nodes); }, []);\n};\n","/**\n * list of the object to be considered as focusable\n */\nexport var tabbables = [\n    'button:enabled',\n    'select:enabled',\n    'textarea:enabled',\n    'input:enabled',\n    // elements with explicit roles will also use explicit tabindex\n    // '[role=\"button\"]',\n    'a[href]',\n    'area[href]',\n    'summary',\n    'iframe',\n    'object',\n    'embed',\n    'audio[controls]',\n    'video[controls]',\n    '[tabindex]',\n    '[contenteditable]',\n    '[autofocus]',\n];\n","import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\n * given list of focusable elements keeps the ones user can interact with\n * @param nodes\n * @param visibilityCache\n */\nexport var filterFocusable = function (nodes, visibilityCache) {\n    return toArray(nodes)\n        .filter(function (node) { return isVisibleCached(visibilityCache, node); })\n        .filter(function (node) { return notHiddenInput(node); });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n    if (cache === void 0) { cache = new Map(); }\n    return toArray(nodes).filter(function (node) { return isAutoFocusAllowedCached(cache, node); });\n};\n/**\n * !__WARNING__! Low level API.\n * @returns all tabbable nodes\n *\n * @see {@link getFocusableNodes} to get any focusable element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\n * !__WARNING__! Low level API.\n *\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\n * (without guards, as long as they are not expected to be ever focused)\n *\n * @see {@link getTabbableNodes} to get only tabble nodes element\n *\n * @param topNodes - array of top level HTMLElements to search inside\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\n */\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\n * return list of nodes which are expected to be auto-focused\n * @param topNode\n * @param visibilityCache\n */\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n    return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\n * Determines if element is contained in scope, including nested shadow DOMs\n */\nexport var contains = function (scope, element) {\n    if (scope.shadowRoot) {\n        return contains(scope.shadowRoot, element);\n    }\n    else {\n        if (Object.getPrototypeOf(scope).contains !== undefined &&\n            Object.getPrototypeOf(scope).contains.call(scope, element)) {\n            return true;\n        }\n        return toArray(scope.children).some(function (child) {\n            var _a;\n            if (child instanceof HTMLIFrameElement) {\n                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\n                if (iframeBody) {\n                    return contains(iframeBody, element);\n                }\n                return false;\n            }\n            return contains(child, element);\n        });\n    }\n};\n","/**\n * returns active element from document or from nested shadowdoms\n */\nimport { safeProbe } from './safe';\n/**\n * returns current active element. If the active element is a \"container\" itself(shadowRoot or iframe) returns active element inside it\n * @param [inDocument]\n */\nexport var getActiveElement = function (inDocument) {\n    if (inDocument === void 0) { inDocument = document; }\n    if (!inDocument || !inDocument.activeElement) {\n        return undefined;\n    }\n    var activeElement = inDocument.activeElement;\n    return (activeElement.shadowRoot\n        ? getActiveElement(activeElement.shadowRoot)\n        : activeElement instanceof HTMLIFrameElement && safeProbe(function () { return activeElement.contentWindow.document; })\n            ? getActiveElement(activeElement.contentWindow.document)\n            : activeElement);\n};\n","export var safeProbe = function (cb) {\n    try {\n        return cb();\n    }\n    catch (e) {\n        return undefined;\n    }\n};\n","import { FOCUS_DISABLED, FOCUS_GROUP } from '../constants';\nimport { asArray, toArray } from './array';\n/**\n * in case of multiple nodes nested inside each other\n * keeps only top ones\n * this is O(nlogn)\n * @param nodes\n * @returns {*}\n */\nvar filterNested = function (nodes) {\n    var contained = new Set();\n    var l = nodes.length;\n    for (var i = 0; i < l; i += 1) {\n        for (var j = i + 1; j < l; j += 1) {\n            var position = nodes[i].compareDocumentPosition(nodes[j]);\n            /* eslint-disable no-bitwise */\n            if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {\n                contained.add(j);\n            }\n            if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {\n                contained.add(i);\n            }\n            /* eslint-enable */\n        }\n    }\n    return nodes.filter(function (_, index) { return !contained.has(index); });\n};\n/**\n * finds top most parent for a node\n * @param node\n * @returns {*}\n */\nvar getTopParent = function (node) {\n    return node.parentNode ? getTopParent(node.parentNode) : node;\n};\n/**\n * returns all \"focus containers\" inside a given node\n * @param node - node or nodes to look inside\n * @returns Element[]\n */\nexport var getAllAffectedNodes = function (node) {\n    var nodes = asArray(node);\n    return nodes.filter(Boolean).reduce(function (acc, currentNode) {\n        var group = currentNode.getAttribute(FOCUS_GROUP);\n        acc.push.apply(acc, (group\n            ? filterNested(toArray(getTopParent(currentNode).querySelectorAll(\"[\".concat(FOCUS_GROUP, \"=\\\"\").concat(group, \"\\\"]:not([\").concat(FOCUS_DISABLED, \"=\\\"disabled\\\"])\"))))\n            : [currentNode]));\n        return acc;\n    }, []);\n};\n","import { contains } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { getFirst, toArray } from './utils/array';\nimport { getActiveElement } from './utils/getActiveElement';\nvar focusInFrame = function (frame, activeElement) { return frame === activeElement; };\nvar focusInsideIframe = function (topNode, activeElement) {\n    return Boolean(toArray(topNode.querySelectorAll('iframe')).some(function (node) { return focusInFrame(node, activeElement); }));\n};\n/**\n * @returns {Boolean} true, if the current focus is inside given node or nodes.\n * Supports nodes hidden inside shadowDom\n */\nexport var focusInside = function (topNode, activeElement) {\n    // const activeElement = document && getActiveElement();\n    if (activeElement === void 0) { activeElement = getActiveElement(getFirst(topNode).ownerDocument); }\n    if (!activeElement || (activeElement.dataset && activeElement.dataset.focusGuard)) {\n        return false;\n    }\n    return getAllAffectedNodes(topNode).some(function (node) {\n        return contains(node, activeElement) || focusInsideIframe(node, activeElement);\n    });\n};\n","export var focusOn = function (target, focusOptions) {\n    if (!target) {\n        // not clear how, but is possible https://github.com/theKashey/focus-lock/issues/53\n        return;\n    }\n    if ('focus' in target) {\n        target.focus(focusOptions);\n    }\n    if ('contentWindow' in target && target.contentWindow) {\n        target.contentWindow.focus();\n    }\n};\n","import { isRadioElement } from './is';\nvar findSelectedRadio = function (node, nodes) {\n    return nodes\n        .filter(isRadioElement)\n        .filter(function (el) { return el.name === node.name; })\n        .filter(function (el) { return el.checked; })[0] || node;\n};\nexport var correctNode = function (node, nodes) {\n    if (isRadioElement(node) && node.name) {\n        return findSelectedRadio(node, nodes);\n    }\n    return node;\n};\n/**\n * giving a set of radio inputs keeps only selected (tabbable) ones\n * @param nodes\n */\nexport var correctNodes = function (nodes) {\n    // IE11 has no Set(array) constructor\n    var resultSet = new Set();\n    nodes.forEach(function (node) { return resultSet.add(correctNode(node, nodes)); });\n    // using filter to support IE11\n    return nodes.filter(function (node) { return resultSet.has(node); });\n};\n","import { correctNode } from './correctFocus';\nexport var pickFirstFocus = function (nodes) {\n    if (nodes[0] && nodes.length > 1) {\n        return correctNode(nodes[0], nodes);\n    }\n    return nodes[0];\n};\nexport var pickFocusable = function (nodes, node) {\n    return nodes.indexOf(correctNode(node, nodes));\n};\n","import { correctNodes } from './utils/correctFocus';\nimport { pickFocusable } from './utils/firstFocus';\nimport { isGuard } from './utils/is';\nexport var NEW_FOCUS = 'NEW_FOCUS';\n/**\n * Main solver for the \"find next focus\" question\n * @param innerNodes - used to control \"return focus\"\n * @param innerTabbables - used to control \"autofocus\"\n * @param outerNodes\n * @param activeElement\n * @param lastNode\n * @returns {number|string|undefined|*}\n */\nexport var newFocus = function (innerNodes, innerTabbables, outerNodes, activeElement, lastNode) {\n    var cnt = innerNodes.length;\n    var firstFocus = innerNodes[0];\n    var lastFocus = innerNodes[cnt - 1];\n    var isOnGuard = isGuard(activeElement);\n    // focus is inside\n    if (activeElement && innerNodes.indexOf(activeElement) >= 0) {\n        return undefined;\n    }\n    var activeIndex = activeElement !== undefined ? outerNodes.indexOf(activeElement) : -1;\n    var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;\n    var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;\n    // no active focus (or focus is on the body)\n    if (activeIndex === -1) {\n        // known fallback\n        if (lastNodeInside !== -1) {\n            return lastNodeInside;\n        }\n        return NEW_FOCUS;\n    }\n    // new focus, nothing to calculate\n    if (lastNodeInside === -1) {\n        return NEW_FOCUS;\n    }\n    var indexDiff = activeIndex - lastIndex;\n    var firstNodeIndex = outerNodes.indexOf(firstFocus);\n    var lastNodeIndex = outerNodes.indexOf(lastFocus);\n    var correctedNodes = correctNodes(outerNodes);\n    var correctedIndex = activeElement !== undefined ? correctedNodes.indexOf(activeElement) : -1;\n    var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);\n    // old focus\n    if (!indexDiff && lastNodeInside >= 0) {\n        return lastNodeInside;\n    }\n    // no tabbable elements, autofocus is not possible\n    if (innerTabbables.length === 0) {\n        // an edge case with no tabbable elements\n        // return the last focusable one\n        // with some probability this will prevent focus from cycling across the lock, but there is no tabbale elements to cycle to\n        return lastNodeInside;\n    }\n    var returnFirstNode = pickFocusable(innerNodes, innerTabbables[0]);\n    var returnLastNode = pickFocusable(innerNodes, innerTabbables[innerTabbables.length - 1]);\n    // first element\n    if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnLastNode;\n    }\n    // last element\n    if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {\n        return returnFirstNode;\n    }\n    // jump out, but not on the guard\n    if (indexDiff && Math.abs(correctedIndexDiff) > 1) {\n        return lastNodeInside;\n    }\n    // focus above lock\n    if (activeIndex <= firstNodeIndex) {\n        return returnLastNode;\n    }\n    // focus below lock\n    if (activeIndex > lastNodeIndex) {\n        return returnFirstNode;\n    }\n    // index is inside tab order, but outside Lock\n    if (indexDiff) {\n        if (Math.abs(indexDiff) > 1) {\n            return lastNodeInside;\n        }\n        return (cnt + lastNodeInside + indexDiff) % cnt;\n    }\n    // do nothing\n    return undefined;\n};\n","import { filterAutoFocusable } from './DOMutils';\nimport { pickFirstFocus } from './firstFocus';\nimport { getDataset } from './is';\nvar findAutoFocused = function (autoFocusables) {\n    return function (node) {\n        var _a;\n        var autofocus = (_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus;\n        return (\n        // @ts-expect-error\n        node.autofocus ||\n            //\n            (autofocus !== undefined && autofocus !== 'false') ||\n            //\n            autoFocusables.indexOf(node) >= 0);\n    };\n};\nexport var pickAutofocus = function (nodesIndexes, orderedNodes, groups) {\n    var nodes = nodesIndexes.map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var autoFocusable = filterAutoFocusable(nodes.filter(findAutoFocused(groups)));\n    if (autoFocusable && autoFocusable.length) {\n        return pickFirstFocus(autoFocusable);\n    }\n    return pickFirstFocus(filterAutoFocusable(orderedNodes));\n};\n","import { parentAutofocusables } from './DOMutils';\nimport { contains } from './DOMutils';\nimport { asArray } from './array';\nvar getParents = function (node, parents) {\n    if (parents === void 0) { parents = []; }\n    parents.push(node);\n    if (node.parentNode) {\n        getParents(node.parentNode.host || node.parentNode, parents);\n    }\n    return parents;\n};\n/**\n * finds a parent for both nodeA and nodeB\n * @param nodeA\n * @param nodeB\n * @returns {boolean|*}\n */\nexport var getCommonParent = function (nodeA, nodeB) {\n    var parentsA = getParents(nodeA);\n    var parentsB = getParents(nodeB);\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < parentsA.length; i += 1) {\n        var currentParent = parentsA[i];\n        if (parentsB.indexOf(currentParent) >= 0) {\n            return currentParent;\n        }\n    }\n    return false;\n};\nexport var getTopCommonParent = function (baseActiveElement, leftEntry, rightEntries) {\n    var activeElements = asArray(baseActiveElement);\n    var leftEntries = asArray(leftEntry);\n    var activeElement = activeElements[0];\n    var topCommon = false;\n    leftEntries.filter(Boolean).forEach(function (entry) {\n        topCommon = getCommonParent(topCommon || entry, entry) || topCommon;\n        rightEntries.filter(Boolean).forEach(function (subEntry) {\n            var common = getCommonParent(activeElement, subEntry);\n            if (common) {\n                if (!topCommon || contains(common, topCommon)) {\n                    topCommon = common;\n                }\n                else {\n                    topCommon = getCommonParent(common, topCommon);\n                }\n            }\n        });\n    });\n    // TODO: add assert here?\n    return topCommon;\n};\n/**\n * return list of nodes which are expected to be autofocused inside a given top nodes\n * @param entries\n * @param visibilityCache\n */\nexport var allParentAutofocusables = function (entries, visibilityCache) {\n    return entries.reduce(function (acc, node) { return acc.concat(parentAutofocusables(node, visibilityCache)); }, []);\n};\n","import { NEW_FOCUS, newFocus } from './solver';\nimport { getFocusableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { asArray, getFirst } from './utils/array';\nimport { pickAutofocus } from './utils/auto-focus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\nvar reorderNodes = function (srcNodes, dstNodes) {\n    var remap = new Map();\n    // no Set(dstNodes) for IE11 :(\n    dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });\n    // remap to dstNodes\n    return srcNodes.map(function (node) { return remap.get(node); }).filter(isDefined);\n};\n/**\n * contains the main logic of the `focus-lock` package.\n *\n * ! you probably dont need this function !\n *\n * given top node(s) and the last active element returns the element to be focused next\n * @returns element which should be focused to move focus inside\n * @param topNode\n * @param lastNode\n */\nexport var focusSolver = function (topNode, lastNode) {\n    var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);\n    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n    var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n    var visibilityCache = new Map();\n    var anyFocusable = getFocusableNodes(entries, visibilityCache);\n    var innerElements = anyFocusable.filter(function (_a) {\n        var node = _a.node;\n        return isNotAGuard(node);\n    });\n    if (!innerElements[0]) {\n        return undefined;\n    }\n    var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var orderedInnerElements = reorderNodes(outerNodes, innerElements);\n    // collect inner focusable and separately tabbables\n    var innerFocusables = orderedInnerElements.map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var innerTabbable = orderedInnerElements.filter(function (_a) {\n        var tabIndex = _a.tabIndex;\n        return tabIndex >= 0;\n    }).map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);\n    if (newId === NEW_FOCUS) {\n        var focusNode = \n        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus\n        pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) ||\n            pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache));\n        if (focusNode) {\n            return { node: focusNode };\n        }\n        else {\n            console.warn('focus-lock: cannot find any node to move focus into');\n            return undefined;\n        }\n    }\n    if (newId === undefined) {\n        return newId;\n    }\n    return orderedInnerElements[newId];\n};\n","import { focusOn } from './commands';\nimport { focusSolver } from './focusSolver';\nvar guardCount = 0;\nvar lockDisabled = false;\n/**\n * The main functionality of the focus-lock package\n *\n * Contains focus at a given node.\n * The last focused element will help to determine which element(first or last) should be focused.\n * The found element will be focused.\n *\n * This is one time action (move), not a persistent focus-lock\n *\n * HTML markers (see {@link import('./constants').FOCUS_AUTO} constants) can control autofocus\n * @see {@link focusSolver} for the same functionality without autofocus\n */\nexport var moveFocusInside = function (topNode, lastNode, options) {\n    if (options === void 0) { options = {}; }\n    var focusable = focusSolver(topNode, lastNode);\n    // global local side effect to countain recursive lock activation and resolve focus-fighting\n    if (lockDisabled) {\n        return;\n    }\n    if (focusable) {\n        /** +FOCUS-FIGHTING prevention **/\n        if (guardCount > 2) {\n            // we have recursive entered back the lock activation\n            console.error('FocusLock: focus-fighting detected. Only one focus management system could be active. ' +\n                'See https://github.com/theKashey/focus-lock/#focus-fighting');\n            lockDisabled = true;\n            setTimeout(function () {\n                lockDisabled = false;\n            }, 1);\n            return;\n        }\n        guardCount++;\n        focusOn(focusable.node, options.focusOptions);\n        guardCount--;\n    }\n};\n","import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n    if (!element || !scope) {\n        console.error('no element or scope given');\n        return {};\n    }\n    var shards = asArray(scope);\n    if (shards.every(function (shard) { return !contains(shard, element); })) {\n        console.error('Active element is not contained in the scope');\n        return {};\n    }\n    var focusables = useTabbables\n        ? getTabbableNodes(shards, new Map())\n        : getFocusableNodes(shards, new Map());\n    var current = focusables.findIndex(function (_a) {\n        var node = _a.node;\n        return node === element;\n    });\n    if (current === -1) {\n        // an edge case, when anchor element is not found\n        return undefined;\n    }\n    return {\n        prev: focusables[current - 1],\n        next: focusables[current + 1],\n        first: focusables[0],\n        last: focusables[focusables.length - 1],\n    };\n};\nvar getBoundary = function (shards, useTabbables) {\n    var set = useTabbables\n        ? getTabbableNodes(asArray(shards), new Map())\n        : getFocusableNodes(asArray(shards), new Map());\n    return {\n        first: set[0],\n        last: set[set.length - 1],\n    };\n};\nvar defaultOptions = function (options) {\n    return Object.assign({\n        scope: document.body,\n        cycle: true,\n        onlyTabbable: true,\n    }, options);\n};\nvar moveFocus = function (fromElement, options, cb) {\n    if (options === void 0) { options = {}; }\n    var newOptions = defaultOptions(options);\n    var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n    if (!solution) {\n        return;\n    }\n    var target = cb(solution, newOptions.cycle);\n    if (target) {\n        focusOn(target.node, newOptions.focusOptions);\n    }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var next = _a.next, first = _a.first;\n        return next || (cycle && first);\n    });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var prev = _a.prev, last = _a.last;\n        return prev || (cycle && last);\n    });\n};\nvar pickBoundary = function (scope, options, what) {\n    var _a;\n    var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n    var node = boundary[what];\n    if (node) {\n        focusOn(node.node, options.focusOptions);\n    }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusFirstElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusLastElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'last');\n};\n","import { getTabbableNodes } from './utils/DOMutils';\nfunction weakRef(value) {\n    if (!value)\n        return null;\n    var w = value ? new WeakRef(value) : null;\n    return function () { return (w === null || w === void 0 ? void 0 : w.deref()) || null; };\n}\nexport var recordElementLocation = function (element) {\n    if (!element) {\n        return null;\n    }\n    var stack = [];\n    var currentElement = element;\n    while (currentElement && currentElement !== document.body) {\n        stack.push({\n            current: weakRef(currentElement),\n            parent: weakRef(currentElement.parentElement),\n            left: weakRef(currentElement.previousElementSibling),\n            right: weakRef(currentElement.nextElementSibling),\n        });\n        currentElement = currentElement.parentElement;\n    }\n    return {\n        element: weakRef(element),\n        stack: stack,\n        ownerDocument: element.ownerDocument,\n    };\n};\nvar restoreFocusTo = function (location) {\n    var _a, _b, _c, _d, _e;\n    if (!location) {\n        return undefined;\n    }\n    var stack = location.stack, ownerDocument = location.ownerDocument;\n    var visibilityCache = new Map();\n    for (var _i = 0, stack_1 = stack; _i < stack_1.length; _i++) {\n        var line = stack_1[_i];\n        var parent_1 = (_a = line.parent) === null || _a === void 0 ? void 0 : _a.call(line);\n        // is it still here?\n        if (parent_1 && ownerDocument.contains(parent_1)) {\n            var left = (_b = line.left) === null || _b === void 0 ? void 0 : _b.call(line);\n            var savedCurrent = line.current();\n            var current = parent_1.contains(savedCurrent) ? savedCurrent : undefined;\n            var right = (_c = line.right) === null || _c === void 0 ? void 0 : _c.call(line);\n            var focusables = getTabbableNodes([parent_1], visibilityCache);\n            var aim = \n            // that is element itself\n            (_e = (_d = current !== null && current !== void 0 ? current : \n            // or something in it's place\n            left === null || left === void 0 ? void 0 : left.nextElementSibling) !== null && _d !== void 0 ? _d : \n            // or somebody to the right, still close enough\n            right) !== null && _e !== void 0 ? _e : \n            // or somebody to the left, something?\n            left;\n            while (aim) {\n                for (var _f = 0, focusables_1 = focusables; _f < focusables_1.length; _f++) {\n                    var focusable = focusables_1[_f];\n                    if (aim === null || aim === void 0 ? void 0 : aim.contains(focusable.node)) {\n                        return focusable.node;\n                    }\n                }\n                aim = aim.nextElementSibling;\n            }\n            if (focusables.length) {\n                // if parent contains a focusable - move there\n                return focusables[0].node;\n            }\n        }\n    }\n    // nothing matched\n    return undefined;\n};\n/**\n * Captures the current focused element to restore focus as close as possible in the future\n * Handles situations where the focused element is removed from the DOM or no longer focusable\n * moving focus to the closest focusable element\n * @param targetElement - element where focus should be restored\n * @returns a function returning a new element to focus\n */\nexport var captureFocusRestore = function (targetElement) {\n    var location = recordElementLocation(targetElement);\n    return function () {\n        return restoreFocusTo(location);\n    };\n};\n","export function deferAction(action) {\n  setTimeout(action, 1);\n}\nexport var inlineProp = function inlineProp(name, value) {\n  var obj = {};\n  obj[name] = value;\n  return obj;\n};\nexport var extractRef = function extractRef(ref) {\n  return ref && 'current' in ref ? ref.current : ref;\n};","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport withSideEffect from 'react-clientside-effect';\nimport { moveFocusInside, focusInside, focusIsHidden, expandFocusableNodes, focusNextElement, focusPrevElement, focusFirstElement, focusLastElement, captureFocusRestore } from 'focus-lock';\nimport { deferAction, extractRef } from './util';\nimport { mediumFocus, mediumBlur, mediumEffect } from './medium';\nvar focusOnBody = function focusOnBody() {\n  return document && document.activeElement === document.body;\n};\nvar isFreeFocus = function isFreeFocus() {\n  return focusOnBody() || focusIsHidden();\n};\nvar lastActiveTrap = null;\nvar lastActiveFocus = null;\nvar lastPortaledElement = null;\nvar focusWasOutsideWindow = false;\nvar defaultWhitelist = function defaultWhitelist() {\n  return true;\n};\nvar focusWhitelisted = function focusWhitelisted(activeElement) {\n  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);\n};\nvar recordPortal = function recordPortal(observerNode, portaledElement) {\n  lastPortaledElement = {\n    observerNode: observerNode,\n    portaledElement: portaledElement\n  };\n};\nvar focusIsPortaledPair = function focusIsPortaledPair(element) {\n  return lastPortaledElement && lastPortaledElement.portaledElement === element;\n};\nfunction autoGuard(startIndex, end, step, allNodes) {\n  var lastGuard = null;\n  var i = startIndex;\n  do {\n    var item = allNodes[i];\n    if (item.guard) {\n      if (item.node.dataset.focusAutoGuard) {\n        lastGuard = item;\n      }\n    } else if (item.lockItem) {\n      if (i !== startIndex) {\n        return;\n      }\n      lastGuard = null;\n    } else {\n      break;\n    }\n  } while ((i += step) !== end);\n  if (lastGuard) {\n    lastGuard.node.tabIndex = 0;\n  }\n}\nvar focusWasOutside = function focusWasOutside(crossFrameOption) {\n  if (crossFrameOption) {\n    return Boolean(focusWasOutsideWindow);\n  }\n  return focusWasOutsideWindow === 'meanwhile';\n};\nvar checkInHost = function checkInHost(check, el, boundary) {\n  return el && (el.host === check && (!el.activeElement || boundary.contains(el.activeElement)) || el.parentNode && checkInHost(check, el.parentNode, boundary));\n};\nvar withinHost = function withinHost(activeElement, workingArea) {\n  return workingArea.some(function (area) {\n    return checkInHost(activeElement, area, area);\n  });\n};\nvar activateTrap = function activateTrap() {\n  var result = false;\n  if (lastActiveTrap) {\n    var _lastActiveTrap = lastActiveTrap,\n      observed = _lastActiveTrap.observed,\n      persistentFocus = _lastActiveTrap.persistentFocus,\n      autoFocus = _lastActiveTrap.autoFocus,\n      shards = _lastActiveTrap.shards,\n      crossFrame = _lastActiveTrap.crossFrame,\n      focusOptions = _lastActiveTrap.focusOptions;\n    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;\n    var activeElement = document && document.activeElement;\n    if (workingNode) {\n      var workingArea = [workingNode].concat(shards.map(extractRef).filter(Boolean));\n      if (!activeElement || focusWhitelisted(activeElement)) {\n        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {\n          if (workingNode && !(focusInside(workingArea) || activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement, workingNode))) {\n            if (document && !lastActiveFocus && activeElement && !autoFocus) {\n              if (activeElement.blur) {\n                activeElement.blur();\n              }\n              document.body.focus();\n            } else {\n              result = moveFocusInside(workingArea, lastActiveFocus, {\n                focusOptions: focusOptions\n              });\n              lastPortaledElement = {};\n            }\n          }\n          focusWasOutsideWindow = false;\n          lastActiveFocus = document && document.activeElement;\n        }\n      }\n      if (document && activeElement !== document.activeElement && document.querySelector('[data-focus-auto-guard]')) {\n        var newActiveElement = document && document.activeElement;\n        var allNodes = expandFocusableNodes(workingArea);\n        var focusedIndex = allNodes.map(function (_ref) {\n          var node = _ref.node;\n          return node;\n        }).indexOf(newActiveElement);\n        if (focusedIndex > -1) {\n          allNodes.filter(function (_ref2) {\n            var guard = _ref2.guard,\n              node = _ref2.node;\n            return guard && node.dataset.focusAutoGuard;\n          }).forEach(function (_ref3) {\n            var node = _ref3.node;\n            return node.removeAttribute('tabIndex');\n          });\n          autoGuard(focusedIndex, allNodes.length, +1, allNodes);\n          autoGuard(focusedIndex, -1, -1, allNodes);\n        }\n      }\n    }\n  }\n  return result;\n};\nvar onTrap = function onTrap(event) {\n  if (activateTrap() && event) {\n    event.stopPropagation();\n    event.preventDefault();\n  }\n};\nvar onBlur = function onBlur() {\n  return deferAction(activateTrap);\n};\nvar onFocus = function onFocus(event) {\n  var source = event.target;\n  var currentNode = event.currentTarget;\n  if (!currentNode.contains(source)) {\n    recordPortal(currentNode, source);\n  }\n};\nvar FocusWatcher = function FocusWatcher() {\n  return null;\n};\nvar FocusTrap = function FocusTrap(_ref4) {\n  var children = _ref4.children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    onBlur: onBlur,\n    onFocus: onFocus\n  }, children);\n};\nFocusTrap.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: PropTypes.node.isRequired\n} : {};\nvar onWindowBlur = function onWindowBlur() {\n  focusWasOutsideWindow = 'just';\n  deferAction(function () {\n    focusWasOutsideWindow = 'meanwhile';\n  });\n};\nvar attachHandler = function attachHandler() {\n  document.addEventListener('focusin', onTrap);\n  document.addEventListener('focusout', onBlur);\n  window.addEventListener('blur', onWindowBlur);\n};\nvar detachHandler = function detachHandler() {\n  document.removeEventListener('focusin', onTrap);\n  document.removeEventListener('focusout', onBlur);\n  window.removeEventListener('blur', onWindowBlur);\n};\nfunction reducePropsToState(propsList) {\n  return propsList.filter(function (_ref5) {\n    var disabled = _ref5.disabled;\n    return !disabled;\n  });\n}\nvar focusLockAPI = {\n  moveFocusInside: moveFocusInside,\n  focusInside: focusInside,\n  focusNextElement: focusNextElement,\n  focusPrevElement: focusPrevElement,\n  focusFirstElement: focusFirstElement,\n  focusLastElement: focusLastElement,\n  captureFocusRestore: captureFocusRestore\n};\nfunction handleStateChangeOnClient(traps) {\n  var trap = traps.slice(-1)[0];\n  if (trap && !lastActiveTrap) {\n    attachHandler();\n  }\n  var lastTrap = lastActiveTrap;\n  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;\n  lastActiveTrap = trap;\n  if (lastTrap && !sameTrap) {\n    lastTrap.onDeactivation();\n    if (!traps.filter(function (_ref6) {\n      var id = _ref6.id;\n      return id === lastTrap.id;\n    }).length) {\n      lastTrap.returnFocus(!trap);\n    }\n  }\n  if (trap) {\n    lastActiveFocus = null;\n    if (!sameTrap || lastTrap.observed !== trap.observed) {\n      trap.onActivation(focusLockAPI);\n    }\n    activateTrap(true);\n    deferAction(activateTrap);\n  } else {\n    detachHandler();\n    lastActiveFocus = null;\n  }\n}\nmediumFocus.assignSyncMedium(onFocus);\nmediumBlur.assignMedium(onBlur);\nmediumEffect.assignMedium(function (cb) {\n  return cb(focusLockAPI);\n});\nexport default withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);","import { FOCUS_ALLOW } from './constants';\nimport { contains } from './utils/DOMutils';\nimport { toArray } from './utils/array';\nimport { getActiveElement } from './utils/getActiveElement';\n/**\n * checks if focus is hidden FROM the focus-lock\n * ie contained inside a node focus-lock shall ignore\n *\n * This is a utility function coupled with {@link FOCUS_ALLOW} constant\n *\n * @returns {boolean} focus is currently is in \"allow\" area\n */\nexport var focusIsHidden = function (inDocument) {\n    if (inDocument === void 0) { inDocument = document; }\n    var activeElement = getActiveElement(inDocument);\n    if (!activeElement) {\n        return false;\n    }\n    // this does not support setting FOCUS_ALLOW within shadow dom\n    return toArray(inDocument.querySelectorAll(\"[\".concat(FOCUS_ALLOW, \"]\"))).some(function (node) { return contains(node, activeElement); });\n};\n","import { getAllAffectedNodes } from './utils/all-affected';\nimport { isGuard, isNotAGuard } from './utils/is';\nimport { getTopCommonParent } from './utils/parenting';\nimport { orderByTabIndex } from './utils/tabOrder';\nimport { getFocusables } from './utils/tabUtils';\n/**\n * traverses all related nodes (including groups) returning a list of all nodes(outer and internal) with meta information\n * This is low-level API!\n * @returns list of focusable elements inside a given top(!) node.\n * @see {@link getFocusableNodes} providing a simpler API\n */\nexport var expandFocusableNodes = function (topNode) {\n    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n    var commonParent = getTopCommonParent(topNode, topNode, entries);\n    var outerNodes = orderByTabIndex(getFocusables([commonParent], true), true, true);\n    var innerElements = getFocusables(entries, false);\n    return outerNodes.map(function (_a) {\n        var node = _a.node, index = _a.index;\n        return ({\n            node: node,\n            index: index,\n            lockItem: innerElements.indexOf(node) >= 0,\n            guard: isGuard(node),\n        });\n    });\n};\n","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport FocusLockUI from './Lock';\nimport FocusTrap from './Trap';\nvar FocusLockCombination = /*#__PURE__*/React.forwardRef(function FocusLockUICombination(props, ref) {\n  return /*#__PURE__*/React.createElement(FocusLockUI, _extends({\n    sideCar: FocusTrap,\n    ref: ref\n  }, props));\n});\nvar _ref = FocusLockUI.propTypes || {},\n  sideCar = _ref.sideCar,\n  propTypes = _objectWithoutPropertiesLoose(_ref, [\"sideCar\"]);\nFocusLockCombination.propTypes = process.env.NODE_ENV !== \"production\" ? propTypes : {};\nexport default FocusLockCombination;","import FocusLock from './Combination';\nexport * from './UI';\nexport default FocusLock;"],"sourceRoot":""}